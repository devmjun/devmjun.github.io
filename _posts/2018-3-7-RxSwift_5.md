---
layout:     post
title:      "RxSwift. 기초 정리하기 (5)"
subtitle:   "Operator 기초를 정리해보자, Combning Operators, Merging, Triggers, Switches"
date:       2018-03-07 09:00:00
author:     "MinJun"
header-img: "img/tags/RxSwift-bg.jpg"
comments: true 
tags: [RxSwift]
---

Raywenderlich-Ebook의 RxSwift를 읽고 정리한 내용입니다.
아래 내용의 저작권과 이미지는 모두 [https:/www.raywenderlich.com/](https://www.raywenderlich.com/) 에 있습니다. 더 자세한 내용은 [여기서 책을 구입해주세요!](https://store.raywenderlich.com/products/rxswift)

---



## RxSwift 정리 (5) 

- Combining Operators
	- Prefixing and concatenation 
	- Observable.concat
	- concat
	- concat one element
- Merging 
	- Combining elemnets
	- combineLatest
	- zip
- Triggers 
	- withLatestFrom
- Switches
	- amb
	- switchLatest 
	- Combining elements within a sequence 
	- scan 
- Reference 

---

## Combining Operators  

Swift의 Collection 연산자들과 매우 유사합니다. Swift의 배열과 마찬가지로 asynchronous sequences의 요소들을 결합하는데 도움이 됩니다. 

RxSwift는 모든 비동기 작업을 마스터링 합니다. 복잡한 데이터들이 떠다니는 환경에서 Combining Operator이 도움을 줄것입니다.

---

#### - Prefixing and concatenation 

Observable을 다루는 첫번째이자 가장 분명한것은 초기값을 받도록 보장하는것 입니다. 현재상태가 첫번째로 필요한 상황의 예로는 '현재 상태', '네트워크 연결상태' 입니다.<br>

<center><img src="/img/posts/Combining_Operators.png" width="700" height="350"></center> <br> 

```swift
let numbers = Observable.of(2, 3, 4)
let observable = numbers.startWith(10)

observable.subscribe(onNext: { value in
        print(value) // 10 2 3 4 
    })
```

Observable의 요소는 2,3,4 이지만, 출력값의 초기값은 10입니다.

---

#### - Observable.concat

`startWith(_:)`은 `concat`의 여러 변형된 모양 입니다. 결국 `startWith(_:)`은 다른 시퀀스에 또다른 시퀀스를 추가하는 방법입니다. `Observable.concat(_:)`은 두개의 시퀀스를 연결합니다. <br>

<center><img src="/img/posts/Combining_Operators-1.png" width="700" height="350"></center> <br> 

```swift
let first = Observable.of(10, 20, 30)
let second = Observable.of(4, 5, 6)
let observable = Observable.concat([first, second])

observable.subscribe(onNext: { value in
		print(value) // 10 20 30 4 5 6
    })
```

---

#### - concat 

```swift
let germanCities = Observable.of("Berlin", "Münich", "Frankfurt")
let spanishCities = Observable.of("Madrid", "Barcelona", "Valencia")
let oservable = germanCities.concat(spanishCities)
	.subscribe(onNext: {
		print($0) // Berlin Münich Frankfurt Madrid Barcelona Valencia
    })
```

---

#### - concat one element

```swift
let numbers = Observable.of(2, 3, 4)
let observable = Observable
	.just(20)
	.concat(numbers)
	observable.subscribe(onNext: { value in
		print(value) // 20 2 3 4
    })
```

> Note: Observables sequence are strongly typed. 동일한 유형의 요소가 있는 시퀀스만 연결할수 있습니다. 타입이 다르면 연결이 되지않고, 컴파일 에러를 방출합니다. Observable<String> 일때 Observable<Int>를 concat 하려고 하면 컴파일 에러를 방출 합니다. 
> 
> 시퀀스를 `추가`하는 방법을 알아보았으니, 여러 시퀀스의 요소들을 `결합` 하는 방법을 알아봅니다!

---

## Merging 

RxSwift는 여러가지 Merge 방법을 제공합니다. 

<center><img src="/img/posts/Combining_Operators-2.png" width="700" height="350"></center> <br> 

```swift
let left = PublishSubject<String>()
let right = PublishSubject<String>()
let source = Observable.of(left.asObservable(), right.asObservable())
let observable = source.merge()
let disposable = observable.subscribe(onNext: { value in
		print(value)
    })
    
var leftValues = ["Berlin", "Munich", "Frankfurt"]
var rightValues = ["Madrid", "Barcelona", "Valencia"]
repeat {
		if arc4random_uniform(2) == 0 {
		if !leftValues.isEmpty {
				left.onNext("Left:  " + leftValues.removeFirst())
			}
		} else if !rightValues.isEmpty {
            right.onNext("Right: " + rightValues.removeFirst())
        }
    } while !leftValues.isEmpty || !rightValues.isEmpty

-----------
Right: Madrid
Right: Barcelona
Left:  Berlin
Left:  Munich
Left:  Frankfurt
Right: Valencia
```

- merge() 는 source sequence 가 완료되고, 모든 inner sequences가 완료되었을때 완료 됩니다.
- sequence중 하나라도 오류를 방출하면, Observable은 즉시 오류를 방출하고 종료합니다. 
- merge()는 Observable source를 얻을수 있고, 그 자체는 Observable 의 연속적인 요소 타입들을 방출합니다.
- 즉, merge()에 subscirbe 하기 위해 다른 많은 연속적인 observable sequence를 보낼수 있습니다. 
- `merge(maxConcurrent:)`를 사용하여 구독의 개수를 제한할수 있습니다. macConcurrent의 제한에 도달할때 까지 들어오는 시퀀스를 계속 구독합니다. 그 다음에 들어오는 시퀀스들은 queue에 넣습니다. 그 다음, 현재 시퀀스중 하나가 완료 되자마자 순서대로 구독 할것입니다. 

---

## Combining elemnets 

내부(결합된) sequence 하나가 값을 방출할때마다 사용자가 제공한 closure 가 호출됩니다. 각각 내부의 sequence에서 최신의 값을 받고, 값을 결합하거나  여러 소스의 상태를 보는 것등을 할수 있습니다.

<center><img src="/img/posts/Combining_Operators-3.png" width="700" height="350"></center> <br> 

```swift
let left = PublishSubject<String>()
let right = PublishSubject<String>()
    
let observable = Observable.combineLatest(left, right, resultSelector: ({ lastleft, lastright in
        "\(lastleft) \(lastright)"
    }))
let disposable = observable.subscribe(onNext: { value in
        print(value)
    })
print("> Sending a value to Left")
left.onNext("Hello,")
print("> Sending a value to Right")
right.onNext("world")
print("> Sending another value to Right")
right.onNext("RxSwift")
print("> Sending another value to Left")
left.onNext("Have a good day,")
disposable.dispose()    

-------------------------
> Sending a value to Left
> Sending a value to Right
Hello, world
> Sending another value to Right
Hello, RxSwift
> Sending another value to Left
Have a good day, RxSwift
```

Observalbe의 값을 받을때, Closure의 실행 시점을 명확하게 확인할수 있습니다. 

> Note: combineLatest (_ : _ : resultSelector :)는 Clsoure를 호출하기 전에, Observalbe의 한 요소를 방출할때가지 기다립니다. 그것은 혼란스러울수 있으며, sequence의 초기값을 제공하기 위해서 startWith(_:)를 사용하여 혼란을 방지할수 있습니다. 

일반적인 패턴은 값을 튜플에 결합한 다음, 체인으로 전달하는 경우입니다.

```swift
let observable = Observable.combineLatest(left, right) { ($0, $1) }
	.filter { !$0.0.isEmpty }
	.subscribe(onNext: {
      print($0)
    })
```  

---


#### - combineLatest

```swift
let choice : Observable<DateFormatter.Style> = Observable.of(.short, .long)
let dates = Observable.of(Date())
let observable = Observable.combineLatest(choice, dates) {
        (format, when) -> String in
        let formatter = DateFormatter()
        formatter.dateStyle = format
        return formatter.string(from: when)
    }
observable.subscribe(onNext: { value in
        print(value) // March 3, 2018
    })
    
----
3/3/18
March 3, 2018
```

combineLatest는 내부의 마지막 seqeuces가 완료될때만 완료됩니다. 이전에 결합된 값을 계속 전송합니다. 일부 시퀀스가 종료하면 마지막 값과 결합하여 다른 시퀀스의 새 값과 결합합니다.


---


#### - zip

<center><img src="/img/posts/Combining_Operators-4.png" width="700" height="350"></center> <br> 

```swift
enum Weather {
	case cloudy
	case sunny
}
let left: Observable<Weather> = Observable.of(.sunny, .cloudy, .cloudy, .sunny)
let right = Observable.of("Lisbon", "Copenhagen", "London", "Madrid", "Vienna")
    
let observable = Observable
	.zip(left, right) { weather, city in
		return "It`s Weather is \(weather), in \(city)"
	}
	.subscribe(onNext: {
		print($0)
	})

--------------------------
It`s Weather is sunny, in Lisbon
It`s Weather is cloudy, in Copenhagen
It`s Weather is cloudy, in London
It`s Weather is sunny, in Madrid
```

- Observalbe을 구독합니다. 
- 각각 새로운 값을 방출하기를 기다립니다.
- 두가지 새로운 값으로 Closure를 호출 합니다. Vienna가 방출되지 않은 이유는, 각각의 Observable에서 값을 방출하고 그중 하나가 완료되면 zip도 완성 됩니다. 
- 모든 내부 관측값이 완료될때 까지 기다리지 않습니다. 이를 `indexed sequencing` 라고 합니다. 

> Note: Swift도 zip(_ : _:) collection 연산자가 있습니다. 두 컬렉션 항목이 포함된 새로운 튜플 컬렉션을 만듭니다. 이게 다입니다. RxSwift는 2~8개의 Observables을 제공하고, combineLatest처럼 콜렉션 변형을 제공합니다.

```swift
let sequence1: [Int] = [1,2,3,4]
let sequence2: [Int] = [10,20,30,40]
let zipSequence = zip(sequence1, sequence2)
for item in zipSequence {
    print(item)
}
----------
(1, 10)
(2, 20)
(3, 30)
(4, 40)
```

---


## Triggers 

#### - withLatestFrom


앱은 다양한 요구를 가지고 있으며, 여러 입력 소스를 관리해야 합니다. 한번에 여러 관측 자료의 입력을 받기도하고, 일부는 코드에서 액션을 시작해서 다른 액션에 데이터를 제공할때도 있습니다. <br>

<center><img src="/img/posts/triggers.png" width="700" height="350"></center> <br> 


```swift
let button = PublishSubject<Void>()
let textField = PublishSubject<String>()
let observable = button.withLatestFrom(textField)
let disposeable = observable.subscribe(onNext: { value in
			print(value)
    })
    
textField.onNext("Par")
textField.onNext("Pari")
textField.onNext("Paris")
    
// 아래의 두줄은 목적에 맞게 작성됬습니다. 실제로 동작하지 않는 코드
button.onNext()
button.onNext()
```

원하는 값이 있을때 다른 액션을 받으면 다음 행동을 취할수 있게 만드는것을 도와줍니다. `withLatestFrom(_:)`은 특정 트리거가 발생할 때만 Observable에서 방출된 최신값을 얻을수 있습니다.

<center><img src="/img/posts/triggers-1.png" width="700" height="350"></center> <br> 

```swift
let observable = textField.sample(button)
```

> Note: `withLatestFrom(_:)`은 data를 observable 매개변수로 취하는 반면 `sample(_:)`은 triggerfmf Observable을 매개변수로 사용한다는것을 잊으면 안됩니다.

---


## Switches 

RxSwift에는 `amb(_:)`, `switchLatest()`라는 두가지 주요 Switching 연산자가 있습니다. 

두개의 연산자 모두 결합된 seqeunce 또는 source sequences의 이벤트를 switching 하여 obserable sequence를 생성할수 있습니다.

이를 통해 런타임에 subscribe가 수신할 sequence event를 결정할수 있습니다. 

---


#### - amb 

<center><img src="/img/posts/Switches.png" width="700" height="350"></center> <br> 

```swift
let left = PublishSubject<String>()
let right = PublishSubject<String>()
    
let observable = left.amb(right)
let disposeable = observable.subscribe(onNext: {
        print($0)
    })
left.onNext("Lisbon")
right.onNext("Copenhagen") // 출력안됨
left.onNext("London")
left.onNext("Madrid")
right.onNext("Vienna") // 출력안됨
disposeable.dispose()
```

`amb(_:)`는 이름 처럼 모호하게 작동합니다. left, right의 관측 값을 구독합니다. 둘중 하나의 요소를 방출한 다음 다른 요소로부터 구독을 취소할떄까지 기다립니다. 그 후에 첫번째 활성 관찰 요소의 요소만 값을 방출합니다. 

값을 방출하기 이전에는 어떤 sequence를 지속적으로 방출할지 알수 없지만, 하나의 값이 방출되면 그 이후부터 어떤값을 계속 방출할지 확인할수 있습니다.

---


#### - switchLatest 

이 연산자는 종종 사용하지 않는데, 좋은 예가 있습니다. 중복 서버에 연결하고 먼저 응답하는 서버의 값을 받는다고 생각해보세요!

<center><img src="/img/posts/Switches-1.png" width="700" height="350"></center> <br> 

```swift
let one = PublishSubject<String>()
let two = PublishSubject<String>()
let three = PublishSubject<String>()
let source = PublishSubject<Observable<String>>()
source.switchLatest()
    
let disposable = source.subscribe(onNext: { value in
		print(value)
})
    
source.onNext(one)
one.onNext("Some text from sequence one")
two.onNext("Some text from sequence two")
source.onNext(two)
    
two.onNext("More text from sequence two")
one.onNext("and also from sequence one")
source.onNext(three)
two.onNext("Why don't you see me?")
one.onNext("I'm alone, help me")
three.onNext("Hey it's three. I win.")
source.onNext(one)
one.onNext("Nope. It's me, one!")
source.dispose()
------------
Some text from sequence one
More text from sequence two
Hey it's three. I win.
Nope. It's me, one!
```

아래의 출력되는 스트링이 원하는대로 출력이 안될수 있습니다. 하지만 `switchLatest()`의 동작과정을 보는데 충분합니다.

---

#### - Combining elements within a sequence 

Swift의 Reduce를 알고 있을것입니다. RxSwift도 Reduce가 있습니다.

<center><img src="/img/posts/Combining_elements.png" width="700" height="350"></center> <br> 

```swift
let source = Observable.of(1,2,3,4,5)
let source1 = Observable.of(1,2,3,4,5,6,7,8,9,10)
source
		.reduce(0, accumulator: +)
				.subscribe(onNext: {
					print($0) //15
		        })
    
let observable = source1
	.reduce(0, accumulator: { summary, newValue in
			return summary + newValue
	})
	.subscribe(onNext: {
			print($0) // 55
	}) 
```

연산자는 summary값을 `accumulates(누적)`합니다. 이 값을 사용자가 제공한 초기값으로 시작합니다. reduce(_ :_ :)는 새로운 요약을 생성하기 위해 closure를 호출합니다. source Observable값이 완료되면 reduce(_ : _:) 가 요약값을 내보낸 다음 완료됩니다.

---

#### - scan 

Observerable이 요소를 하나 바울할 때마다 scan(_ : accumulator :)이 Clsoure를 호출합니다. 새 요소와 함께 실행중인 값을 전달하고, Closure는 새 누적값을 반환합니다. 

<center><img src="/img/posts/Combining_elements-1.png" width="700" height="350"></center> <br> 

```swift
let source = Observable.of(1, 3, 5, 7, 9)
    
let observable = source.scan(0, accumulator: +)
observable.subscribe(onNext: { value in
		print(value) // 1 4 9 16 25
    })
```

- 예제 연습

목적: 현재 값과, 누적된 값을 동시에 출력해보세요

```swift
let x = Observable.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).scan(0, accumulator: +)
    let y = Observable.of(10, 20, 30, 40, 50, 60, 70, 80, 90, 100).scan(0, accumulator: +)
    let observable = Observable.zip(x, y) { x, y in
        return (x, y)
    }
    observable.subscribe(onNext: {
        print("current value = \($0.0) + \($0.1) -> \($0.0 + $0.1)")
    })
```

---

## Reference 

* 공식 

[http://reactivex.io](http://reactivex.io/documentation/ko/observable.html) <br> 
[Getting Started Rxswift](https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#observables-aka-sequences) <br>
[Introduce to Rx](http://www.introtorx.com/Content/v1.0.10621.0/00_Foreword.html) <br>
[RxJS Marbles](http://rxmarbles.com/) <br>
[RxSwift github](https://github.com/ReactiveX/RxSwift) <br>
[http://community.rxswift.org/](http://community.rxswift.org/) <br>

---






























