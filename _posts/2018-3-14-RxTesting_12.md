---
layout:     post
title:      "RxTests. 기초 정리하기 (12)"
subtitle:   "Testing with RxTest, hot, cold ovservables, RxBlocking, scheduler, toBlocking()"
date:       2018-03-14 19:40:00
author:     "MinJun"
header-img: "img/tags/RxCocoa-bg.jpg"
comments: true 
tags: [RxSwift, RxCocoa]
---

Raywenderlich-Ebook의 RxSwift를 읽고 정리한 내용입니다.

---

## RxCocoa 정리 (12) 

- Testing With RxTest 
- Getting started 
- Testing operators with RxTest 
	- What are hot and cold observables?
	- Using RxBlocking 
- Testing RxSwift production code 
- Reference 

---

## Testing With RxTest 

이 장은 당신을 위한 장이기 때문에 건너뛰지 않는것을 추천합니다. 그런데 개발자들을 test를 건너뛰는 2가지 이유가 있습니다.

1. 그들은 버그가 없는 코드를 작성합니다.
2. tests하는것은 재미 없습니다.

첫번째 이유라면 당신은 채용됩니다. 두번째 이유라면 `RxTest`에 대해서 소개 드리겠습니다. 

이책을 읽기 시작한 이유와 앱 프로젝트에서 `RxSwift`를 사용하게 되어 기븝니다. `RxTest`(및 RxBlocking)는 `RxSwift`코드에 대한 테스트를 작성하게 되어 매우 기쁩니다.

테스트를 쉽고 재미있게 작성하는 고급 API를 제공합니다. 

이 장에서 여러 `RxSwift` 작업에 대한 테스트를 작성하고 프로덕션 `RxSwift`코드에 대한 테스트를 작성하여 `RxTest` 및  `RxBlocking`을 소개합니다.

---

## Getting started 

이장의 프로젝트는 `Testing`라는 이름으로 지어졌고 16진수 컬러코드의 RGB 값과 색상이름(사용가능한경우)을 제공하는 편리한 앱이 포함되어 있습니다. 

pod 파일을 설치한후 프로젝트를 시작합니다. 앱이 `rayWnederlichGreen`으로 시작하지만 16진수 색상코드를 입력하고 rgb 및 이름값을 얻을수 있습니다. <br>

<center><img src="/img/posts/RxSwift_Testing.png" width="500" height="300"></center> <br> 

이 응용프로그램은 `MVVM` 디자인 패턴을 사용하여 구성되었습니다. 이 패턴에 대한 내용은 `MVVM`장에서 배우게 됩니다. 

Suffice it to say that the view model is where the logic is housed that the view controller will use to control the view.(`뷰 모델은` 뷰 컨트롤러가 뷰를 제어하기위해 사용할 로직이 있는 곳 이라고 말하면 충분합니다.)

인기 있는 색상 이름을 모델로 열거 하는 외에도 전체 application은 이 논리에서 실행됩니다. 이 논리는 나중에 이 장의 뒷부분에서 테스트를 작성합니다.(???)

```swift
// Convert hex text to color
color = hexString.asObservable()
  .map { hex in
    guard hex.characters.count == 7 else { return .clear }
    let color = UIColor(hex: hex)
    return color
  }
  .asDriver(onErrorJustReturn: .clear)
// Convert the color to an rgb tuple
rgb = color.asObservable()
  .map { color in
    var red: CGFloat = 0.0
    var green: CGFloat = 0.0
    var blue: CGFloat = 0.0
    color.getRed(&red, green: &green, blue: &blue, alpha: nil)
        let rgb = (Int(red * 255.0), Int(green * 255.0), Int(blue * 255.0))
return rgb }
  .asDriver(onErrorJustReturn: (0, 0, 0))
// Convert the hex text to a matching name
colorName = hexString.asObservable()
  .map { hexString in
    let hex = String(hexString.characters.dropFirst())
    if let color = ColorName(rawValue: hex) {
      return "\(color)"
} else {
return "--" }
  }
  .asDriver(onErrorJustReturn: "")
```

위의 테스트 코드를 테스트하기전에 `RxSwift`연산자에 대한 몇가지 테스트를 작성하여 `RxTest`에 대해 알아 보는것이 도움이 됩니다. 

> Note: 이장에서 `XCTest`를 사용하여 iOS 단위 테스트를 작성하는 것이 익숙하다고 가정합니다. 처음이라면 [https://videos.raywenderlich.com/courses/beginning-ios-unit-and-ui-testing/lessons/1](https://videos.raywenderlich.com/courses/beginning-ios-unit-and-ui-testing/lessons/1) 를 확인하십시오.
> 

---

## Testing operators with RxTest 

> `RxTest`는 최근에 `Swift Package Manager` 문제로 인해 `RxTests`에서 이름이 변경된것입니다. 
> 
> 따라서 다른곳에서 사용할때 `RxTests`가 `RxTest`를 참조할 가능성이 큽니다. 

`RxTest`는 `RxSwift`와는 별도의 라이브러리 입니다. 별도의 POD 설치및 import가 필요합니다. 

`RxTest`는 RxSwift 코드 테스트에 유용한 추가 기능을 제공합니다. `TestScheduler`는 가상 시간 스케줄러로 시간 선형 작업 테스트를 세부적으로 제어하며 `next(_: _:)`, `complted(_ : _:)`등의 메소드를 제공합니다. `error(_: _:)`를 사용하여 테스트에서 지정된 시간에 Observable 이벤트에 이벤트를 추가할수 있습니다.

차갑거나 뜨거운 샌드위치로 생각할수 있는것처럼(???) 그것은 또한 hot/cold observable을 생각해야합니다.

---

### What are hot and cold observables?

RxSwift는 Rx코드를 합리화 간소화 하기 위해 유연하게 대처합니다. 여기에 hot/cold 의 차이를 느끼게 해주는 생각의 서클이 있습니다. 

`RxSwift`가 concrete types 대신 `observable trait`으로 더많이 생각할수 있습니다.  

이것은 구현의 세부 사항중 일부 이지만 테스트중에 `RxSwift`에서 hot/cold observable에 대해 많은 이야기를 하지 않끼 때문에 알아 두어야할 가치가 있습니다.

- **Hot obserables**
	- subscribe 가 있는지 여부에 상관없이(있어도 사용, 없어도 사용) 리소스를 사용합니다. 
	- subscribers가 있든 없든 요소들(elements)을 생산합니다 
	- 주로 `Variable` 같은 상태 저장 유형과 함께 사용됩니다. 
- **Cold observables**
	- Subscription 위에서만 리소스를 사용합니다. 
	- Subscribers가 있는 경우에만 요소들(elements)를 생산합니다.
	- 주로 네트워킹과 같은 비동기 작업에 사용됩니다.  
 
곧 작성하게 될 단위 테스트에서 `hot observables`을 사용 할것입니다. 그러나 필요에 따라 다른 것을 사용하도록 요구한느 경우의 차이를 아는것이 좋습니다. 

`TestingTest`그룹에서 `TestingOperators.swift`를 엽니다. `TestOperators` 클래스에 몇가지 속성이 있습니다.

```swift
var scheduler: TestScheduler!
var subscription: Disposable!
```

`scheduler`는 각 테스트에서 사용할 `TestScheduler`의 인스턴스 이며 `subscription`은 각 테스트에서 구독을 잡고(hold)있습니다.

`setUp()`의 정의를 다음과 일치 하도록 변경하세요.

```swift
override func setUp() {
  super.setUp()
  scheduler = TestScheduler(initialClock: 0)
}
```

각 테스트 케이스가 시작되기 전에 호출되는 `setUp()` 메소드는(tests의 set은 나의 케이스에 `Testingopreators`를 포함합니다)에서 `initialClock`값이 0인 새 스케줄러를 초기화합니다. 

즉, 테스트 시작시 테스트 스케줄러를 시작하려고 합니다. 이제 `tearDown()`에서 아래의 코드를 작성합니다

```swift
override func tearDown() {
  scheduler.scheduleAt(1000) {
    self.subscription.dispose()
  }
  super.tearDown()
}
``` 

`tearDown()`은 각 테스트가 완료될때 호출됩니다. 이 테스트에서 1000(milliseconds)초에 테스트 구독을 처리하도록 예약합니다. 

작성한 각 테스트는 `1초 미만 동안` 실행되므로 테스트 구독을 `1초 내`에 처분하는것이 안전합니다. 

그리고 이제 test를 작성할 시간입니다. `tearDown()`정의 후 `TestingOperators`에서 이 새 테스트를 추가 하십시오. 

```swift
func testAmb() {
// 2
  let observer = scheduler.createObserver(String.self)
}
```

1. `XCTest`를 사용하는 모든 테스트와 마찬가지고 메서드의 이름은 `test`로 시작해야합니다. `amb`연산자에 대한 새로운 테스트를 시작하세요 
2. 스케줄러의 `create Observaer(_:)` 메소드를 사용하여 `String` 타입인 observable을 작성합니다. 

`observer`는 수신한 모든 이벤트를 기록하고 타임스템프(timestamp)처리 합니다. `RxSwift`의 디버그 연산자와 비슷하지만 아무것도 출력하지 않는 경우는 예외입니다. 

`Combining Operators`장에서 `amb`연산자에 대해 배웠습니다. 

`amb`은 두 `observable`간에 사용되며 둘중 먼저 `observable`을 방사하는 이벤트를 전파합니다. 

`amb`을 테스트하려면 두개의 observable 만들어야 합니다. 테스트를 위해 다음 코드를 추가하세요 

```swift
// 1
let observableA = scheduler.createHotObservable([
  // 2
  next(100, "a)"),
  next(200, "b)"),
  next(300, "c)")
  ])
// 3
let observableB = scheduler.createHotObservable([
  // 4
  next(90, "1)"),
  next(200, "2)"),
  next(300, "3)")
  ])
```

1. 스케줄러가 만든 Hot Observable(_:)을 사용하여 observableA를 작성합니다. 
2. `next(_ : _:)`를 사용하여 두번째 매개변수로 전달된 값으로 지정된 시간(밀리초)에 `observableA`에 .`next` 이벤트를 추가합니다
3. observableB hot observable을 만듭니다.
4. 지정된 시간에 지정된 값으로 `observableB`에 `.next`이벤트를 추가하세요 <br>

<center><img src="/img/posts/RxSwift_Testing-1.png" width="500" height="300"></center> <br> 

`amb`을 이해하면 먼저 발생하는 `observable`에 의해 생성된 이벤트가 전달되므로 이 두 `observables`사이에 `amb`을 사용하면 `observableB`의 요소가 수신되어야함을 테스트에서 확인할수 있습니다. 

이를 테스트하려면 다음코드를 추가하여 `amb`연산자를 사용하고 결과를 로컬 상수에 할당 하세요.

```swift
let ambObservable = observableA.amb(observableB)
```

`ambObservable`을 Option 키를 눌러서 클릭하면 `Observable<String>` 타입임을 확인할수 있습니다. <br>

<center><img src="/img/posts/RxSwift_Testing-2.png" width="500" height="300"></center> <br> 

> Note: Xcode가 `fritz`(?)에 있는 경우 <<error type>>가 표시 될수도 있습니다. Xcode가 test를 실행하면 수정하기 때문에 걱정하지 않아도 됩니다.

다음으로 `scheduler`에게 특정 시간에 `schedule an action`을 지시하도록 합니다.

```swift
scheduler.scheduleAt(0) {
  self.subscription = ambObservable.subscribe(observer)
}
```

여기서는 `ambObservable`이 0시에 observable를 구독하도록 예약하고 구독을 구독 속성에 할당합니다. 이렇게하면 `tearDown()`이 구독을 처리합니다. 

실제로 테스트를 시작한 다음 결과를 확인하려면 다음 코드를 추가하세요

```swift
scheduler.start()
```

그러면 가상 시간 스케줄러가 시작되고 `observer`는 `amb`작업을 통해 지정한 `.next`이벤트를 받습니다. 

이제 결과를 수집하고 분석할수 있습니다. 아래의 코드를 입력하세요 

```swift
let results = observer.events.map {
  $0.value.element!
}
```

observer`s의 이벤트들 속성에 map을 사용하여 각 이벤트의 요소에 접근합니다. 

이제 다음 코드를 추가하여 실제 결과가 예상 결과와 일치한다고 주장할수 있습니다.

이제 `func testAmb()`를 실행해봅니다. Xcode가 이 테스트를 빌드하고 실행한후 성공했음을 알수 있습니다.(일명 합격)<br>

| Lanuch screen | First screen | 
| :--: | :--: |
|![screen](/img/posts/RxSwift_Testing-3.png) | ![screen](/img/posts/RxSwift_Testing-4.png)| <br>

일반적으로 예상된 결과를 알고있으면 되는것과 되지않는것을 테스트하는것과 같이 이 것을 보완하기 위해 부정적인 테스트를 만들것입니다. 

이장이 끝나기 전에 더 많은 테스트를 작성해야 하므로 테스트가 제대로 작동하는지 테스트를 하려면 다음과 일치하도록 주장을 변경해보세요

```swift
XCTAssertEqual(results, ["1)", "2)", "No you didn't!"])
```

테스트를 다시 실행하고 실패와 함께 오류 메세지가 출력되는지 확인하세요. 

```swift
XCTAssertEqual failed: ("["1)", "2)", "3)"]") is not equal to ("["1)",
"2)", "No you didn't!"]")
```

변경사항을 취소하고 테스트를 다시 실행한 다음 다시 통과하는지 확인하세요. 

연산자 필터링하는것에 대해 전체장을 보았으므로 왜 테스트하지 않습니까? 이 테스트를 `testingOperator`에 추가합니다. 이 테스트는 `testAmb()`과 완전히 같은 형식을 따릅니다

```swift
func testFilter() {
        // 1
        let observer = scheduler.createObserver(Int.self)
        // 2
        let observable = scheduler.createHotObservable([
            next(100, 1),
            next(200, 2),
            next(300, 3),
            next(400, 2),
            next(500, 1)
            ])
        // 3
        // 3보다 작은 값을 필터합니다.
        let filterObservable = observable.filter { $0 < 3 }
        
        // 4
        // filterObservable가 observer를 구독합니다.
        scheduler.scheduleAt(0) { self.subscription = filterObservable.subscribe(observer) }
        
        // 5
        scheduler.start()
        // 6
        let results = observer.events.map { $0.value.element! }
        
        // 7
        XCTAssertEqual(results, [1, 2, 2, 1])
    }
```

1. `Int` 타입의 observer를 만듭니다. 
2. `.next`이벤트를 5초동안 매초 스케줄(예약?) 하는 hot observable을 만듭니다
3. `filterObservable`을 작성하여 요소값이 3보다 작은 값을 필터합니다.
4. 구독시간을 0에서 시작하도록 스케줄(예약?)하고 `subscription`속성에 할당하여 `tearDown()`에서 삭제합니다. 
5. 스케줄러를 시작하세요
6. 결과를 수집하세요
7. 결과가 예상한 값이 라고 주장하세요
8. 테스트를 실행하고 통과하는지 확인하세요. 

이러한 테스트는 동기식입니다(synchronous). 비동기 작업을 테스트하려는 경우에는 몇가지 선택 사항이 있습니다. 

`RxBlocking`을 사용하여 가장 쉬운 방법을 먼저 배웁니다. 

---

## Using RxBlocking 

`RxBlocking`은 또다른 라이브러리 입니다. 자체 pod가 있고, 별도로 가져와야합니다. 

주요 목적은 `observable`을 `toBlocking(timeout:)` 메서드를 통해서 `BlockingObservable`로 변환하는 것입니다. 

이것은 `observable`이 종료될때까지 현재 스레드를 차단하거나, 시간초과값(기본값은 nil)을 지정하고 `observable`객체가 종료되기 전에 시간 초과에 도달하면 `RxError.timeout`오류를 발생합니다.(기본 비동기 테스팅이 observable로 옮겨 갔다고 생각하면 될듯..)

이것은 기본적으로 비동기 작업을 동기 작업으로 변환하여 테스트를 훨씬 쉽게 만듭니다. 

`TestingOperators`에 이 테스트를 추가하여 `RxBlocking`을 사용하여 `toArray`의 연산자를 세줄의 코드로 테스트 합니다. 

```swift
func testToArray() {
  // 1
  let scheduler = ConcurrentDispatchQueueScheduler(qos: .default)
// 2
  let toArrayObservable = Observable.of("1)",
"2)").subscribeOn(scheduler)
// 3
  XCTAssertEqual(try! toArrayObservable.toBlocking().toArray(), ["1)",
"2)"])
}
```

1. 서비스의 default quality 값과 함께 비동기 테스트를 실행하는 concurrent scheduler를 생성하세요.

2. 스케줄러에서 두개의 문자열 observable에 등록한 결과를 보유하기위한 observable을 생성하세요.

3. `toArrayObservable`에서 `toBlocking()`을 호출한 결과에 대해 `toArray`를 사용하고 `toArray`의 반환값이 예상 결과와 같다고 가정합니다.

`toBlocking()`은 `toArrayObservable`을 blocking observable로 변환하고 종료될떄까지 스케줄러에 의해 생성된 스레드를 차단합니다. 

테스트를 실행하면 성공했음을 알수 있습니다. 비동기 작업을 테스트하는 세줄의 코드!, 곧 `RxBlocking`으로 더 많은 작업을 할것이지만, 이제는 test operator에서 벗어나 앱의 프로덕션 코드에 대한 테스트를 작성해야 할때입니다. 

---

## Testing RxSwift production code 

Testing group(앱의 기본그룹)에서 `ViewModel.swift`를 열어서 시작합니다. 상단에 다음의 속성 정의가 표시됩니다.

```swift
let hexString = Variable<String>("")
let color: Driver<UIColor>
let rgb: Driver<(Int, Int, Int)>
let colorName: Driver<String
```

`hexString`은 ViewController로부터 입력을 받습니다. color, rgb 및 colorName이 출력되고 ViewController는 view에 바인딩합니다.

이 뷰모델의 이니셜라이저에서 observable의 각 출력은 다른 observable을 변환하고 결과를 `Drvier`로 반환하여 초기화 됩니다. 

이 것은 시작부분에 표시되는 코드입니다. 이니셜라이저 아래에는 일반적인 색상 이름을 모델링하는 열거형 정의가 있습니다.

```swift
enum ColorName: String {
  case aliceBlue = "F0F8FF"
  case antiqueWhite = "FAEBD7"
  case aqua = "0080FF"
  // And many more...
```

이제 `ViewController.swift`를 열고 `viewDidLoad()`의 구현부를 봅니다.

```swift
override func viewDidLoad() {
  super.viewDidLoad()
  configureUI()
  guard let textField = self.hexTextField else { return }
  textField.rx.text.orEmpty
    .bindTo(viewModel.hexString)
    .disposed(by: disposeBag)
  for button in buttons {
    button.rx.tap
      .bindNext {
        var shouldUpdate = false
        switch button.titleLabel!.text! {
        case "⊗":
          textField.text = "#"
          shouldUpdate = true
        case "←" where textField.text!.characters.count > 1:
          textField.text = String(textField.text!.characters.dropLast())
          shouldUpdate = true
        case "←":
          break
        case _ where textField.text!.characters.count < 7:
          textField.text!.append(button.titleLabel!.text!)
          shouldUpdate = true
        default:
break
}
        if shouldUpdate {
          textField.sendActions(for: .valueChanged)
        }
}
      .disposed(by: disposeBag)
  }
  viewModel.color
    .drive(onNext: { [unowned self] color in
      UIView.animate(withDuration: 0.2) {
        self.view.backgroundColor = color
        } 
      })
    .disposed(by: disposeBag)
  viewModel.rgb
    .map { "\($0.0), \($0.1), \($0.2)" }
    .drive(rgbTextField.rx.text)
    .disposed(by: disposeBag)
  viewModel.colorName
    .drive(colorNameTextField.rx.text)
    .disposed(by: disposeBag)
}
```

상단에서부터 

1. 텍스트필드의 텍스트(또는 빈 문자열)을 뷰모델의 `hexString`입력에 바인딩합니다.

2. button oulet collection을(여러개의 버튼들) 반복합니다. 텍스트 필드가 `.valueChanged`컨트롤 이벤트를 보내야 하는경우 버튼 탭 및 버튼의 제목을 전환하여 텍스트 필드의 텍스트를 업데이트하는 방법을 결정하고, 

3. view model's의 색상 `driver`을 사용하여 background color을 업데이트 합니다. 

4. view model's의 rgb `driver`을 사용하여 rgb TextField의 텍스트를 업데이트 합니다. 

5. view model`s의 colorName `driver`을 사용하여 `colorNAmeTextField`의 텍스트를 업데이트 합니다. 

앱이 어떻게 작동하는지에 대한 개요를 통해 이제 테스트를 작성할수 있습니다. `TestingTEsts` 그룹에서 `TestingViewModel.swift`를 열고 `setUp()`의 구현을 다음과 같이 일치하도록 변경합니다.

```swift
override func setUp() {
  super.setUp()
  viewModel = ViewModel()
  scheduler = ConcurrentDispatchQueueScheduler(qos: .default)
}
```

여기서 `viewModel`을 앱의 `ViewModel`클래스의 인스턴스로 지정하고 Qos(quality of Service)를 기본값(.default) 으로 정의하고 `Concurrent scheduler`에 할당합니다. 

이제 앱의 `view model`에 대한 테스트 준비가 완료 되었습니다.

먼저 전통적인 `XCTest API`를 사용하여 비동기 테스트를 작성합니다.

view model`s의 color drive의 테스트를 `TestingViewModel`에 추가합니다(전통적으로 접근 방법을 사용합니다) 

```swift
func testColorIsRedWhenHexStringIsFF0000_async() {
  let disposeBag = DisposeBag()
// 1
  let expect = expectation(description: #function)
  // 2
  let expectedColor = UIColor(red: 1.0, green: 0.0, blue: 0.0, alpha:
1.0)
// 3
  var result: UIColor!
}
```

1. `fulfilled`할 `expectation`을 생성합니다.

2. `red color`과 같이 예상된 테스트 결과를 만듭니다.

3. 나중에 지정할 결과를 정의합니다.

이것은 단지 설정(setup) 코드 입니다. 이제 다음 코드를 테스트에 추가하여 `view model's color driver`를 구독합니다. 

```swift
// 1
let expect = expectation(description: #function)
// 2
let expectedColor = UIColor(red: 1.0, green: 0.0, blue: 0.0, alpha: 1.0)
// 3
var result: UIColor!
// 1
viewModel.color.asObservable()
  .skip(1)
  .subscribe(onNext: {
// 2
result = $0
    expect.fulfill()
  })
  .disposed(by: disposeBag)
// 3
viewModel.hexString.value = "#ff0000"
// 4
waitForExpectations(timeout: 1.0) { error in
  guard error == nil else {
    XCTFail(error!.localizedDescription)
return
}
// 5
  XCTAssertEqual(expectedColor, result)
}
```

1. view model's의 `color driver`에 대한 구독을 만듭니다. `Driver`가 구독시 초기 요소를 재생성하므로 첫번째 요소는 건너 뜁니다. 

2. 결과에 `.next` 이벤트 요소를 할당하고 예상된 값에 따라 `fulfill()`을 호출 하십시오. 

3. `view model's`의 observable(a Variable)로 입력된 

4. 새로운 hexString을 추가합니다.

5. 쉬운 `peasy` 그러나 약간 장황하다(verbose).

테스트가 통과 되는지 확인하기 위해 테스트를 실행 하십시오. 

이제 `RxBlocking`을 사용하여 동일한 작업을 수행하는 다음 테스트를 추가하십시오.

```swift
func testColorIsRedWhenHexStringIsFF0000() {
// 1
  let colorObservable =
viewModel.color.asObservable().subscribeOn(scheduler)
// 2
  viewModel.hexString.value = "#ff0000"
// 3
  do {
    guard let result = try colorObservable.toBlocking(timeout:
1.0).first() else { return }
    XCTAssertEqual(result, .red)
  } catch {
    print(error)
  }
}
```

1. `colorObservable`을 생성하고 `concurrent scheduler`에 구독한  observable 결과를 유지 합니다. 

2. 뷰모델의 `hexString`의 새로운값을 observable로 받은 값으로 추가합니다.

3. `guard`를 사용하여 호출 결과를 선택적으로 1초의 시간초과로 `Blocking()`에 바인딩하고 `throw`될 경우 오류를 포착하여 콘솔창에 출력하고 실제 결과가 예상결과와 일치하는지 확인합니다.(전통적인방식과 다르게 fulfill을 사용하지 않아서 편하게 사용가능..)

테스트를 실행하여 성공했는지 확인합니다. 

이는 이전과 통일한 테스트 입니다. 당신은 열심히 일할 필요가 없어졌습니다.

다음으로 아래의 코드를 추가하여 view model에 rgb driver가 주어진 hexString 입력에 대해 예상되는 빨강, 녹색, 파랑 값을 방출하는지 확인합니다.

```swift
func testRgbIs010WhenHexStringIs00FF00() {
// 1
    let rgbObservable =
viewModel.rgb.asObservable().subscribeOn(scheduler)
// 2
    viewModel.hexString.value = "#00ff00"
    // 3
    let result = try! rgbObservable.toBlocking().first()!
    XCTAssertEqual(0 * 255, result.0)
    XCTAssertEqual(1 * 255, result.1)
    XCTAssertEqual(0 * 255, result.2)
}
```

1. scheduler에 있는 구독을 잡는 `rgbObservable`을 생성합니다.

2. observable의 입력값에 있는 view model의 hexString에 새 값을 추가합니다.

3. `rgbObservable`에서 `toBlocking()`을 호출한 첫번째 결과를 검색한 다음 각 값이 해당 기대치와 일치하는지 확인합니다. 

0대 1에서 0에서 255로의 변환은 테스트 이름을 일치시키고 일을 쉽게 따르도록 하기 위한것 이었습니다. 해당 테스트를 실행 하면 성공합니다.

테스트할 드라이버가 하나 더있습니다. 이 테스트를 `TestingViewModel`에 추가합니다.

`TestingViewModel`은 View Model`s의 드라이버가 주어진 `hexString`입력에 대한 올바른 요소를 방출하는지 테스트 합니다. 

```swift
func testColorNameIsRayWenderlichGreenWhenHexStringIs006636() {
// 1
    let colorNameObservable =
viewModel.colorName.asObservable().subscribeOn(scheduler)
// 2
    viewModel.hexString.value = "#006636"
// 3
    XCTAssertEqual("rayWenderlichGreen", try!
colorNameObservable.toBlocking().first()!)
}
```

1. observable을 생성합니다.

2. 테스트 값을 추가합니다.

3. 예상된 값과 주장한값이 실제로 매칭 되는지 확인합니다.

`reinse and repeat` 라는 문구가 마음에 듭니다. test 코드 작성은 항상 쉬워야 합니다. 

이 프로젝트에서 모든 테스트를 실행하려면 `Command-U`를 누르고 모든것은 녹색으로 통과해야합니다.

`RxTest` 및 `RxBlocking`을 사용하여 테스트를 작성하는 것은 `RxSwift`, `RxCocoa(et al)`을 사용하는 데이터 및 UI 바인딩 코드를 작성하는 것과 유사합니다. 

`MVVM`장에서 더 많은 뷰 모델 테스트를 수행할것 이므로 이장에서는 문제없습니다. 

행복한 테스팅! 

> Note: 현재 해당 책에서 Xcode 8.3 이상 버전에서는 테스트가 되지 않습니다. 해당 테스트의 통과를 확인하고 싶으면, 알맞은 버전에 맞게 셋팅하신후 사용하면 좋을것 같습니다.
> 
> [https://developer.apple.com/download/more/](https://developer.apple.com/download/more/) 에서 다른 Xcode 버전을 다운받을수 있습니다. 

---

## Reference 

* 공식 

[http://reactivex.io](http://reactivex.io/documentation/ko/observable.html) <br> 
[Introduce to Rx](http://www.introtorx.com/Content/v1.0.10621.0/00_Foreword.html) <br>
[RxJS Marbles](http://rxmarbles.com/) <br>
[RxSwift github](https://github.com/ReactiveX/RxSwift) <br>
[http://community.rxswift.org/](http://community.rxswift.org/) <br>

* 개인 참조

[https://github.com/ReactiveX/RxSwift/tree/master/RxTest](https://github.com/ReactiveX/RxSwift/tree/master/RxTest) <br>

