---
layout:     post
title:      "RxSwift. 예제로 기초 정리하기 (6)"
subtitle:   "Combining Operators를 연습해보자! 여러개의 Reqeust를 RxSwift를 통해서 관리하는 방법을 연습합니다"
date:       2018-03-03 17:41:00
author:     "MinJun"
header-img: "img/tags/Swift-bg.jpg"
comments: true 
tags: [Swift]
---

Raywenderlich-Ebook의 RxSwift를 읽고 정리한 내용입니다.

---

* 목적: EONET API를 이용해서, 데이터를 가져오고, 가져온 데이터를 Combining Operators를 사용하는 방법을 연습합니다! 

1. https://eonet.sci.gsfc.nasa.gov/docs/v2.1 API를 사용해서, Event범주를 모아 첫번째 화면에 표시하세요

2. 이벤트를 다운로드 하고 각 카테고리의 수를 표시하십시오

3. 사용자가 카테고리를 탭하면 이 카테고리에 대한 이벤트 목록을 표시합니다.

4. 여러상황에서 combineLatest가 얼마나 유용한지 배울수 있습니다. 추가로 startWith, concat, merge, reduce, scane, map, flatMap을 사용합니다. 

---

### Preparing the web backend service 

좋은 어플리케이션은 명확한 아키텍쳐를 가지고 있습니다. EONET API와 통신하는 코드는 ViewController에 존재해서는 안됩니다. Rx와 결합하면, 애플리케이션 내부에서 사용된 데이터를 구분할수 있습니다. 

---

### Generic reqeust technique

- EONET API로 부터 데이터를 요청하세요
- response값을 해석하세요
- 모든 오류가 보호처리 되었는지 확인하세요
- 오류 사례를 다루는것은 항상 중요합니다. errors를 침묵시키지 말아주세요. 

request의 결과로 URLSession`s rx.response는 observable을 만듭니다. 데이터가 돌아오면 코드는 객체를 직렬화 한다음 [String:Any] 로 변환합니다. 

마지막으로 오류를 무시하는 catch 문에 return Observable.empty()를 작성합니다. 



```swift
static func request(endpoint: String, query: [String: Any] = [:]) -> Observable<[String: Any]> {
        do {
            guard let url = URL(string: API)?.appendingPathComponent(endpoint),
                var components = URLComponents(url: url,
                                               resolvingAgainstBaseURL: true) else {
                                                throw EOError.invalidURL(endpoint)
            }
            components.queryItems = try query.flatMap { (key, value) in
                guard let v = value as? CustomStringConvertible else {
                    throw EOError.invalidParameter(key, value)
                }
                return URLQueryItem(name: key, value: v.description)
            }
            guard let finalURL = components.url else {
                throw EOError.invalidURL(endpoint)
            }
            let request = URLRequest(url: finalURL)
            
            // 최종 URL -> Request
            return URLSession.shared.rx.response(request: request)
                .map { _, data -> [String: Any] in
                    print(data)
                    guard let jsonObject = try? JSONSerialization.jsonObject(with: data,
                                                                             options: []),
                        let result = jsonObject as? [String: Any] else {
                            throw EOError.invalidJSON(finalURL.absoluteString)
                    }
                    return result
            }
        } catch {
            return Observable.empty()
        }
    }
```

> Request 결과를 반환하는 함수를 생성합니다.

---

## fetch categories

EONET의 categories를얻으려면, categories API의 endpoint를 작성해야 합니다. 이 카테고리는 거의 변경되지 않으므로 singleton으로 만들어줍니다. 

비동적으로 데이터를 fetching 하기때문에, 노출시키는 가장 좋은 방법은 Observable<[EOCategory]>로 만드는것입니다.

<center><img src="/img/posts/Rx_Request.png" width="500" height="300"></center> <br> 

- 카테고리의 끝 URL에서 데이터를 요청합니다.
- 응답에서 categories 배열을 추출 합니다. 
- EOCategory 객체의 배열에 매핑하고 이름별로 정렬합니다.

여기에서 옵셔널 체이닝을 사용했습니다. 오류를 보호하기 위한 방법인데 좋은 방법은 아닙니다. 개선 해야할 여지가 있습니다. 

```swift
static var categories: Observable<[EOCategory]> = {
        return EONET.request(endpoint: categoriesEndpoint)
            .map { data in
                let categories = data["categories"] as? [[String: Any]] ?? []
                return categories
                    .flatMap(EOCategory.init)
                    .sorted { $0.name < $1.name }
            }
            .shareReplay(1)
    }()
```
The categories observable you created is a singleton (static var). All subscribers will get the same one. 

- The first subscriber triggers the subscription to the request observable. 

- The response maps to an array of categories.
 shareReplay(1) relays all elements to the first subscriber.

- It then replays the last received element to any new subscriber, without re- requesting the data. It acts much like a cache.

가장 핵심은 subscriber가 여러개 일때, request받은 마지막 값을 각 구독자에게 똑같이 재 생성 후 반환해줍니다(`.shareReplay(1)`). 그것은 마치 캐쉬 처럼 동작 합니다. 

---

### Categories view controller 

가져올 이벤트의 값들을 각각 표시합니다. 지금은 간단하게 category요소만 표시합니다. `Variable은 내부적으로 잠금을 구현하기 때문에 background thread에서 업데이트가 발생하더라고 안전합니다.(지금 버전에서는 어떤지 확인 필요)`

`bind(to:)`는 source observable(EONET.categories)를 observer(the categories variable)에 연결합니다. 

<center><img src="/img/posts/Rx_Request-1.png" width="500" height="300"></center> <br> 

```swift
* CategoriesViewController.swift
let categories = Variable<[EOCategory]>([])
let disposeBag = DisposeBag()

*tableView(_:numberOfRowsInSection):
return categories.value.count

*tableVIew(_:cellForRowAt:)
let category = categories.value[indexPath.row]
cell.textLabel?.text = category.name
cell.detailTextLabel?.text = category.description

* startDownload()
let eoCategories = EONET.categories // request 후 값을 [[String: Any]] 형태로 변환된 상태입니다.

eoCategories
  .bind(to: categories)
  .disposed(by: disposeBag)
  
* ViewDidLoad의 startDownload() 이전에 작성합니다
categories
  .asObservable()
  .subscribe(onNext: { [weak self] _ in
    DispatchQueue.main.async {
      self?.tableView?.reloadData()
    }
  })
  .disposed(by: disposeBag)
```

---

### Adding the event download service 

EONET API는 이벤트를 다운로드할 모든이벤트와, 카테고리당 이벤트, 그리고 각각 열린 이벤트와 닫힌 이벤트로 구분합니다. 

EONET API중 열린 이벤트와 닫힌 이벤트를 노출 합니다. 2개의 요청을 한개의 데이터 흐름으로 만들어서 구독자에게 전달하고 싶습니다. 어떻게 해야할까요?

<center><img src="/img/posts/adding_the_event.png" width="500" height="300"></center> <br> 

- request 보낼 함수를 만들고

```
fileprivate static func events(forLast days: Int, closed: Bool) -> Observable<[EOEvent]> {
        return request(endpoint: eventsEndpoint, query: [
            "days": NSNumber(value: days),
            "status": (closed ? "closed" : "open")
            ])
            .map { json in
                guard let raw = json["events"] as? [[String: Any]] else {
                    throw EOError.invalidJSON(eventsEndpoint)
                }
                return raw.flatMap(EOEvent.init)
        }
    }
 
```

- 2개의 요청을 하나의 함수 안에서 실행할수있게 만들어 놓습니다. 이때 Observable은, combining Operator를 통해서 하나로 만들어 줍니다.

```swift
    static func events(forLast days: Int = 360) -> Observable<[EOEvent]> {
        let openEvents = events(forLast: days, closed: false)
        let closedEvents = events(forLast: days, closed: true)
        return openEvents.concat(closedEvents)
    }

```

`.contat`은 observable을 생성합니다. openEvents소스를 완료할때까지 실행합니다. 그 다음 closedEvents를 구독하고 함께 완료합니다. 첫번째 이벤트를 모두 방송하고, 두번째 구독 이벤트를 중계합니다. 오류가 발생하면 즉시 오류를 방출하고 방송을 종료 합니다.

---

### Getting events for categories 

이벤트로 각 카테고리를 채우고 싶지만, 다운로드에는 시간이 필요합니다. 가능한 최상의 UX를 제공하려면 다음을 따라야합니다.

- 지난해의 모든 이벤트를 다운로드 합니다. 
- 각각의 카테고리의 이벤트 숫자를 포함하는 카테고리 리스트를 업데이트 하세요
- disclosure indicator를 추가하세요
- tableView Cell 선택시, 이벤트 리스트 ViewController를 'Push' 하세요

---

### Updating categories with Events 

2개의 Observable을 준비하는것으로 시작합니다. 


<center><img src="/img/posts/adding_the_event-1.png" width="500" height="300"></center> <br> 

```swift
        // eoCategories는, request를 받고 [[String: Any]] 타입으로 만들어져 있는 상태
        let eoCategories = EONET.categories
        
        // Observable이 2개가 한묶음인 함수
        let downloadedEvents = EONET
            .events(forLast: 360)
        
        let updatedCategories = Observable
            .combineLatest(eoCategories, downloadedEvents) { (categories, events) -> [EOCategory] in
                return categories.map { category in
                    var cat = category
                    cat.events = events.filter {
                        $0.categories.contains(category.id)
                    }
                    return cat
                }
        }
        eoCategories
            .concat(updatedCategories)
            .bind(to: categories)
            .disposed(by: disposeBag)
```

Categories 항목에 Event를 추가시키고, 추가시킨것을 바인딩하여, 하나의 데이터 흐름으로 만들어서 사용합니다.

---

### Updating the display 

1년동안의 이벤트를 처리하느라, 숫자가 표시되고, 이벤트 숫자가 카운팅 되기까지 시간이 오래 걸립니다. 그것은 좋아보이지 않습니다. 어떻게 해결할수 있을까요?

<center><img src="/img/posts/Rx_Request-2.png" width="500" height="300"></center> <br> 

```swift
cell.textLabel?.text = "\(category.name) (\(category.events.count))"
cell.accessoryType = (category.events.count > 0) ? .disclosureIndicator : .none
```

---

### Downloading in parallel 

EONET API는 Open, closed 이벤트를 별도로 제공합니다. 지금까지는 `concat(_:)`을 사용하여 순차적으로 가져왔습니다. 대신에 그들을 병렬로 다운로드 하는것이 좋은 방법입니다. 

아래 함수를 교체 합니다. 


<center><img src="/img/posts/adding_the_event-3.png" width="500" height="300"></center> <br> 

```swift
static func events(forLast days: Int = 360) -> Observable<[EOEvent]> {
        let openEvents = events(forLast: days, closed: false)
        let closedEvents = events(forLast: days, closed: true)
        return openEvents.concat(closedEvents)
    }
```

merge() 후, 각 값들을 reduce를 통해서 하나로 합쳐 줍니다.

```swift
return Observable.of(openEvents, closedEvents)
            .merge()
            .reduce([]) { running, new in
                running + new
        }
```

merge()가 Observable을 방출하고, 마지막 결과를 배열로 축소합니다. 빈배열로 시작하고, Observable대상 중 하나가 이벤트 배열을 전달할 때마다 클로저가 호출됩니다. 기존 배열에 새 배열을 추가하고 반환합니다. 모든 Observable이 완료될때까지 reduce가 호출됩니다. 완료되면 reduce는 단일값(현재 상태)을 반환합니다

다운로드 시간이 약간 개선되었습니다. UI코드를 건드리지않고 EONET 서비스의 처리를 변경할수 있다는것은 Rx의 가장 큰 이점입니다. 

---

### event view controller 

앞에서 얻었던 이벤트를 채우고, 슬라이더를 통해서 이벤트의 날짜를 필터링 하는것을 연습해봅니다.

> Note: DisposedBag을 추가하는것이 지쳣다면, NOObject의 서브클레스 오브젝트를 통해서 해결할수 있습니다. RxSwiftCommunity의 NSObject+Rx 라이브러리를 찾아보세요. 

<center><img src="/img/posts/adding_the_event-4.png" width="500" height="300"></center> <br> 


```swift
* EventsViewController.swift

import UIKit
import RxSwift

class EventsViewController : UIViewController, UITableViewDataSource {
    
    @IBOutlet var tableView: UITableView!
    @IBOutlet var slider: UISlider!
    @IBOutlet var daysLabel: UILabel!
    
    let events = Variable<[EOEvent]>([])
    let disposeBag = DisposeBag()
        
    override func viewDidLoad() {
        super.viewDidLoad()
        
        tableView.rowHeight = UITableViewAutomaticDimension
        tableView.estimatedRowHeight = 60
        events.asObservable()
            .subscribe(onNext: { [weak self] _ in
                self?.tableView.reloadData()
            })
            .disposed(by: disposeBag)
    }
    
    @IBAction func sliderAction(slider: UISlider) {
    }
    
    // MARK: UITableViewDataSource
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return events.value.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "eventCell") as! EventCell
        
        let event = events.value[indexPath.row]
        // TableView의 title과 detali View를 셋팅해줌
        cell.configure(event: event)
        return cell
        
    }
    
}

* CategoriesViewController

func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
  let category = categories.value[indexPath.row]
  if !category.events.isEmpty {
    let eventsController =
storyboard!.instantiateViewController(withIdentifier: "events") as!
EventsViewController
    eventsController.title = category.name
    eventsController.events.value = category.events
    navigationController!.pushViewController(eventsController, animated:
true) 
	}
  tableView.deselectRow(at: indexPath, animated: true)
}
```


---

## wiring the days selector

slider의 값에 따라서 Event의 필터링하는 방법을 바인딩합니다

| * | * | 
| :--: | :--: |
|![screen](/img/posts/Rx_Request-4.png) | ![screen](/img/posts/Rx_Request-5.png)|  <br>


```swift
import UIKit
import RxSwift

class EventsViewController : UIViewController, UITableViewDataSource {
    
    @IBOutlet var tableView: UITableView!
    @IBOutlet var slider: UISlider!
    @IBOutlet var daysLabel: UILabel!
    
    let events = Variable<[EOEvent]>([])
    let disposeBag = DisposeBag()
    
    // filter slider
    let days = Variable<Int>(360)
    let filteredEvents = Variable<[EOEvent]>([])
        
    override func viewDidLoad() {
        super.viewDidLoad()
        
        tableView.rowHeight = UITableViewAutomaticDimension
        tableView.estimatedRowHeight = 60
        events.asObservable()
            .subscribe(onNext: { [weak self] _ in
                self?.tableView.reloadData()
            })
            .disposed(by: disposeBag)
        
        Observable.combineLatest(days.asObservable(), events.asObservable()) { (days, events) -> [EOEvent] in
            let maxInterval = TimeInterval(days * 24 * 3600)
            return events.filter { event in
                if let date = event.closeDate {
                    return abs(date.timeIntervalSinceNow) < maxInterval
                }
                return true
            }
            }
            .bind(to: filteredEvents)
            .disposed(by: disposeBag)
        
        filteredEvents.asObservable()
            .subscribe(onNext: { [weak self] _ in
                self?.tableView.reloadData()
            })
            .disposed(by: disposeBag)
        
        days.asObservable()
            .subscribe(onNext: { [weak self] days in
                self?.daysLabel.text = "Last \(days) days"
            })
            .disposed(by: disposeBag)
    }
    
    @IBAction func sliderAction(slider: UISlider) {
        print(slider.value)
        days.value = Int(slider.value)
    }
    
    // MARK: UITableViewDataSource
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return filteredEvents.value.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "eventCell") as! EventCell
        let event = filteredEvents.value[indexPath.row]
        // TableView의 title과 detali View를 셋팅해줌
        cell.configure(event: event)
        return cell
    }
}
```

---

### Splitting event downloads 

마지막으로 할것은, 각 Categories별로 이벤트를 다운로드를 분리해서 표시하는것을 시도해봅니다. 

1. 먼저 Categories를 가져옵니다
2. 각 Category 별로 event를 요청합니다.
3. 새로운 event block이 도착할때마다, categories에 업데이트하고, TableView릘 refresh 하니다. 
4. Categories의 모든 Event가 도착할때까지 계속합니다.


---

### Adding per-category event downloads to EONET 

Categoryies 별로 이벤트를 분리하려면, reqeust할 URL을 분리할수 있어야합니다. 



```swift
* endpoint 를 추가합니다.
fileprivate static func events(forLast days: Int, closed: Bool, endpoint:
String) -> Observable<[EOEvent]> {
  return request(endpoint: endpoint, query: [

* 아래의 events 함수도 수정합니다
static func events(forLast days: Int = 360, category: EOCategory) -> Observable<[EOEvent]> {
let openEvents = events(forLast: days, closed: false, endpoint:
category.endpoint)
let closedEvents = events(forLast: days, closed: true, endpoint:
category.endpoint)
```

---

### Incrementally updating the UI 

categories의 event의 카운트 값이 각각 증가할수 있도록 UI를 업데이트 합니다.

<center><img src="/img/posts/Rx_Request-6.png" width="500" height="300"></center> <br> 

```swift
* CategoriesViewController.swift의 startDownload()
// Observable이 2개가 한묶음인 함수
        let downloadedEvents = eoCategories.flatMap { categories in
            return Observable.from(categories.map { category in
                EONET.events(forLast: 360, category: category)
            })
            } .merge()
        
        let updatedCategories = eoCategories.flatMap { categories in
            downloadedEvents.scan(categories) { updated, events in
                return updated.map { category in
                    let eventsForCategory = EONET.filteredEvents(events: events,
                                                                 forCategory: category)
                    if !eventsForCategory.isEmpty {
                        var cat = category
                        cat.events = cat.events + eventsForCategory
                        return cat
                    }
                    return category
                }
            }
        }
        
        eoCategories
            .concat(updatedCategories)
            .bind(to: categories)
            .disposed(by: disposeBag)

```

> 예를 들어서 25개의 카테고리가 API 있고 그것을 2개씩 request trigger거 한다고 가정했을때 50번의 API Reqeust를 서버에 요청합니다. 이것을 효율적으로 바꿀수 있는강력함 녀석이 있습니다.

```swift
.merge(maxConcurrent: 2)
```

> 이것은 flatMap(_:)이 Observable로 푸시되는 이벤트를 횟수에 관계에없이 동시에 2개만 구독한다는것을 의미합니다. 
> 
> 각 이벤트 다운로드는 두개의 요청(open, closed)을 수행하므로 한번에 4개의 요청만 실행하게 됩니다. 슬롯이 사용 가능할 때 까지 다른 슬롯은 보류상태가 됩니다. -> 결과적으로 request 횟수가 줄어듭니다! 

- 과제
	- request 시작 했을때 Activity indicator 실행 -> 응답이 끝나면 Activity indicator 종료 
	- Categories 다운로드 상태를 프로그래스바를 통해서 시각적으로 표현해보기 


---

## Referece 

* 공식 

[http://reactivex.io](http://reactivex.io/documentation/ko/observable.html) <br> 
[Getting Started Rxswift](https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#observables-aka-sequences) <br>
[Introduce to Rx](http://www.introtorx.com/Content/v1.0.10621.0/00_Foreword.html) <br>
[RxJS Marbles](http://rxmarbles.com/) <br>
[RxSwift github](https://github.com/ReactiveX/RxSwift) <br>
[http://community.rxswift.org/](http://community.rxswift.org/) <br>

* 개인 참조 

[https://eonet.sci.gsfc.nasa.gov/ API 사용처](https://eonet.sci.gsfc.nasa.gov/) <br>
[Project 주소입니다.](https://github.com/devminjun/RxSwift_Practice) <br>