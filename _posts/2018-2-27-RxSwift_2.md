---
layout:     post
title:      "RxSwift. Operator 기초 정리하기 (2)"
subtitle:   "Filtering Operators, Skipping operators, taking operators, Distinct operators"
date:       2018-02-27 21:49:00
author:     "MinJun"
header-img: "img/tags/Swift-bg.jpg"
comments: true 
tags: [Swift]
---

Raywenderlich-Ebook의 RxSwift를 읽고 정리한 내용입니다.

---


## RxSwift 정리 (2) 

- Operators Practices
- Filtering Operators 
	- Ignoring operators
	- elementAt
	- filter 
	- Skipping operators
		- skip
		- skipWhile
		- skipUntil
- takeking operators 
	- take
	- takeWhileWithIndex 
	- takeUntil 
- Distinct operators
	- distinctUntilchanged 
- Reference 

---

## Operators Practices

Observerable 에서 방출되는 이벤트를 변환하고, 처리하고 이에 대응할수 있습니다. +, -, / 와 같은 간단한 산술 연산자를 결합하여 복잡한 수학 표현식을 만들 수 있는 것처럼 Rx의 간단한 연산자를 결합하고 구성하여 복잡한 응용 프로그램 논리를 표현할수 있습니다. 

마지막으로 시간 지연처리, 일정기간에 걸친 이벤트 그룹화, 시간처리를 수행할수 있는 연산자를 확인해보자.

---

## filtering Operators 

Swift의 filter 를 사용해봤다면 반쯤 왔습니다! 

---

### - Ignoring operators

Observable로 방출되는 요소들을 무시합니다.

<center><img src="/img/posts/Filtering_Operators.png" width="700" height="350"></center> <br> 


```swift
let strikes = PublishSubject<String>()
let disposeBag = DisposeBag()
    
strikes
	.ignoreElements() -> Next 이벤트 무시
	.subscribe { _ in
			print("You out!") // 요소를 출력하지않음
    }.disposed(by: disposeBag)
    
strikes.onNext("X") // 요소 출력 X
strikes.onNext("X") // 요소 출력 X
strikes.onNext("X") // 요소 출력 X
strikes.onCompleted() // You out!
```

`ignoreElements()`는 .onCompleted(), .error 로 인해서 observable이 종료된 이후에 어떤 행동을 취하고 싶을떄 사용하면 유용합니다. <br>

---

### - elementAt

정해진 요소만 방출 합니다.

<center><img src="/img/posts/Filtering_Operators-1.png" width="700" height="350"></center> <br> 

```swift
let strikes = PublishSubject<String>()
let disposeBag = DisposeBag()
    
strikes
	.elementAt(2)
	.subscribe(onNext: { _ in
			print("You're out!")
	})
	.disposed(by: disposeBag)
strikes.onNext("X")
strikes.onNext("X")
strikes.onNext("X")
```

---

### - filter 

<center><img src="/img/posts/Filtering_Operators-2.png" width="700" height="350"></center> <br> 

Ignoring element, elementAt은 Observable 요소들을 필터링합니다. filter의 closure 에서 정의한 각 값이 ture이면 요소들을 방출 합니다.

```swift
let disposeBag = DisposeBag()
  Observable.of(1, 2, 3, 4, 5, 6)
    .filter { integer in
      integer % 2 == 0
    }
    .subscribe(onNext: {
      print($0)
	})
    .disposed(by: disposeBag)
```

---

### - skip

특정 요소의수만큼 방출되는 요소들을 방출하지 않습니다.

<center><img src="/img/posts/Filtering_Operators-3.png" width="700" height="350"></center> <br> 

```swift
let disposeBag = DisposeBag()
	// 1
  Observable.of("A", "B", "C", "D", "E", "F")
    // 2
    .skip(3)
    .subscribe(onNext: {
print($0) })
    .disposed(by: disposeBag)
```

---

### - skipWhile

skipWhile은 skip할수 있는 Observables에 조건을 추가할수 있는데, 조건이 true 이면 방출하지않고 skip하고, false 이면 요소들을 방출합니다.

<center><img src="/img/posts/Filtering_Operators-4.png" width="700" height="350"></center> <br> 

```swift
let bag = DisposeBag()
    Observable.of(3, 2 ,2 ,2 ,2 ,2 ,3, 4, 4)
        .skipWhile{ //element in
            ($0 % 2 == 0)
        }
        .subscribe {
            print($0)
        }
        .disposed(by: bag)
        -> next(3) -> next(4) -> next(4)
```

---

### - skipUntil

skip중인 Observables의 값들중 어떤 `시점`에 트리거로 인해서 이후 observables 값들을 방출하고 싶을때 사용하면 좋습니다.

예시로는 보험금 청구값을 받는데, 요구하는 충족금액을 받을때까지 보험금 승인을 안해주는 어플리케이션을 만들때 사용하면 좋다는......

<center><img src="/img/posts/Filtering_Operators-5.png" width="700" height="350"></center> <br> 

```swift
let bag = DisposeBag()
    
let subject = PublishSubject<String>()
let trigger = PublishSubject<String>()
    
subject.skipUntil(trigger)
	.subscribe {
		print($0)
	}
	.disposed(by: bag)
    
subject.onNext("A")
subject.onNext("B")
trigger.onNext("X")
subject.onNext("C") // next(C)
```

---

## takeking operators 

#### - take

take 연산자는 skip 연산자와 반대로 동작 합니다. 

<center><img src="/img/posts/Filtering_Operators-6.png" width="700" height="350"></center> <br> 

```swift
let disposeBag = DisposeBag()
Observable.of(1, 2, 3, 4, 5, 6)
		.take(3)
		.subscribe(onNext: {
				print($0) // 4 5 6
		}) 
		.disposed(by: disposeBag)
```

---

#### - takeWhileWithIndex 

방출되는 값과 인덱스의 조건을 주어서 원하는 부분만 방출할수 있습니다. 조건이 true인 영역까지 요소들을 방출합니다. 정해놓은 조건이 첫번째 값에서 false라면 그 이후부터는 요소들을 방출하지 않습니다. 조심해서 사용해야 하는 부분인것 같습니다.

<center><img src="/img/posts/Filtering_Operators-7.png" width="700" height="350"></center> <br> 

```swift
let disposeBag = DisposeBag()
Observable.of(2, 2, 4, 4, 6, 6)
	.takeWhileWithIndex { integer, index in
		integer % 2 == 0 && index < 3
	}
	.subscribe(onNext: {
		print($0) // 2 2 4 
	})
	.disposed(by: disposeBag)
```

---

#### - takeUntil 

skipUntil과 반대로 동작합니다. trigger가 시작된 이후부터 요소들을 방출하지 않습니다. <br>

<center><img src="/img/posts/Filtering_Operators-8.png" width="700" height="350"></center> <br> 

```swift
let disposeBag = DisposeBag()
let subject = PublishSubject<String>()
let trigger = PublishSubject<String>()

subject
	.takeUntil(trigger)
	.subscribe(onNext: {
			print($0) 
	})
	.disposed(by: disposeBag)

subject.onNext("1") // 1
subject.onNext("2") // 2
trigger.onNext("Stop") // 출력안됨
subject.onNext("3") // 출력안됨
```

---

## Distinct operators 

#### - distinctUntilchanged

`distinctUntilchanged`는 바로옆의(연속된 중복값) 중복된 값을 방지 합니다. <br>

<center><img src="/img/posts/Filtering_Operators-9.png" width="700" height="350"></center> <br> 

```swift
    let disposeBag = DisposeBag()
    // 1
    Observable.of(1, 2, 3, 3, 4, 1)
    .distinctUntilChanged()
        .subscribe(onNext: {
            print($0) // 1 2 3 4 1 -> 3으로 중복된 값 삭제됨
        })
    .disposed(by: disposeBag)
```

---

## Reference 

* 공식 

[http://reactivex.io](http://reactivex.io/documentation/ko/observable.html) <br> 
[Introduce to Rx](http://www.introtorx.com/Content/v1.0.10621.0/00_Foreword.html) <br>
[RxJS Marbles](http://rxmarbles.com/) <br>
[RxSwift github](https://github.com/ReactiveX/RxSwift) <br>
[http://community.rxswift.org/](http://community.rxswift.org/) <br>


* 일반참고 

[RxSwift 시작하기 전수열님](https://www.slideshare.net/devxoul/rxswift-81314827) <br>
[ashfurrow blog](https://ashfurrow.com/blog/) <br>
[Realm RxSwift 이선협](https://academy.realm.io/kr/posts/reactive-programming-with-rxswift/) <br>
[Realm RxSwift 시작하기 최완복님](https://academy.realm.io/kr/posts/letswift-rxswift/)<br>
[RxSwift로 시작하는 함수형 Reactive 프로그래밍 개론](https://academy.realm.io/kr/posts/slug-max-alexander-functional-reactive-rxswift/) <br>
[RxSwift 예제로 감잡기 : RxSwift 시작을 위한 간단한 예제들 - iOS Tech Talk](https://academy.realm.io/kr/posts/how-to-use-rxswift-with-simple-examples-ios-techtalk/) <br>
[Reactive MVVM(Model-View-ViewModel) 모바일 응용프로그램 아키텍쳐](https://justhackem.wordpress.com/2015/03/19/rmvvm-architecture/)<br>

[RxSwift 기본 익히기 (1) — 10 분짜리](https://medium.com/@trilliwon/rxswift-%EA%B8%B0%EB%B3%B8-%EC%9D%B5%ED%9E%88%EA%B8%B0-1-d4d77ce63ca8) <br>
[RxSwift 기본 익히기 (2) — 10 분짜리](https://medium.com/@trilliwon/rxswift-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-2-9%EB%B6%84-59-%EC%B4%88-f42f28407e75) <br>

[예제로 시작하는 RxSwift #1 - 기초](https://pilgwon.github.io/blog/2017/09/26/RxSwift-By-Examples-1-The-Basics.html)<br>
[예제로 시작하는 RxSwift #2 – 옵저버블(Observable)과 바인드(Bind)](https://pilgwon.github.io/blog/2017/10/09/RxSwift-By-Examples-2-Observable-And-The-Bind.html) <br>
[예제로 시작하는 RxSwift #3 – 네트워킹.](https://pilgwon.github.io/blog/2017/10/10/RxSwift-By-Examples-3-Networking.html)<br>
[예제로 시작하는 RxSwift #4 – 멀티스레딩.](http://www.thedroidsonroids.com/blog/ios/rxswift-examples-4-multithreading/) <br>


---