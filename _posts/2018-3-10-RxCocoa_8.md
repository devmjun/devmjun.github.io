---
layout:     post
title:      "RxCocoa. 기초 정리하기 (8)"
subtitle:   "RxCocoa, BindTo, Traits, ObservableType ObserverType, ControlProperty<T>, entities ControlProperty, Drive, ControlEvent"
date:       2018-03-10 19:53:00
author:     "MinJun"
header-img: "img/tags/RxCocoa-bg.jpg"
comments: true 
tags: [RxCocoa]
---


Raywenderlich-Ebook의 RxSwift를 읽고 정리한 내용입니다.
아래 내용의 저작권과 이미지는 모두 [https:/www.raywenderlich.com/](https://www.raywenderlich.com/) 에 있습니다. 더 자세한 내용은 [여기서 책을 구입해주세요!](https://store.raywenderlich.com/products/rxswift)

---



## RxCocoa 정리 (8) 

- iOS Apps with RxCocoa 
- Beginning Rxcocoa
	- Configure the API Key 
- Using RxCocoa with UIKit controls 
	- Displaying the data using Rxcocoa 
	- Retrieving data from the OpenWeather API
- Binding observables 
	- What are binding observables?
	- Using binding observables to display data 
- Improving the code with Traits 
	- What are Control Property and Drive?
	- Improving the project with Driver and ControlProperty 
- Disposing with RxCocoa 
	- unowned vs weak with RxCocoa
- Where to go from here?
- Challenges
- Reference 

---

## iOS Apps with RxCocoa 

Rx는 멀티 플렛폼 프레임 워크 입니다. RxCocoa는 독립 실행형 라이브러리 입니다(RxSwift와 같이 제공됩니다. 미리 작성된 많은 기능들을 사용하여 UIKit, Cocoa와 더 잘 통합할수 있습니다.

Rxcocoa는 즉시 사용가능한 Networking을 제공하며, 사용자와 상호작용하고 UI와 data를 바인딩 하는등 기본 클레스를 제공합니다.

---

## Beginning Rxcocoa 

[http://openweathermap.org](http://openweathermap.org) API를 이용해서, RxCocoa를 이용해봅니다. 

openweathermap API를 사용하기 위해서는 API Key가 필요합니다. 해당 키는 회원가입후 [https://home.openweathermap.org/api_keys](https://home.openweathermap.org/api_keys) 에서 얻을수 있습니다.

프로퍼티 이름은 좋은 아이디어를 제공합니다. text는 속성이 UItextField 내부의 텍스트와 직접 관려이 있음을 의미합니다. 이제 `UILable + Rx.swift`를 엽니다. Text와 atrributedText라는 두개의 새로운 속성을 볼수 있습니다. 앞에서와 같이 두 이름은 모두 원래 UILabel 구현과 관련되어 있으므로 이름 충돌은 없으며 그 목적은 분명합니다.

`UIBindingObserver`라는 새로운 type가 있습니다. 해당 Observer는 ControlProperty 와 비슷하며, 특별하고 UI작업에 몰두합니다.

`UIbindingobserver`는 기초로직과 UI를 바인딩하는데 사용되며 중요한 것은 오류를 바인딩 할수 없다는(it can`t bind errors) 것입니다.

`UIBinding Observer`에 오류가 전송되면 개발시 Debug 스키마를 실행할때 `fatalError()`가 호출되지만 프로덕션 환경에서 응용 프로그램을 실행할때 오류 로그에 오류가 추가됩니다. 

---

### - Configure the API Key 

[https://home.openweathermap.org/api_keys](https://home.openweathermap.org/api_keys) 해당 주소에서 나의 API Key를 가져와야합니다. 

```swift
private let apiKey = "[YOUR KEY]"
```

---

## Using RxCocoa with UIKit controls 

먼저 프로젝트를 빌드하여 설정을 완료했는지 확인하고, 데이터를 입력하고 온도, 습도 및 도시 이름과 함께 주어진 도시의 날씨를 반환하도록 API에 요청할 준비가 되었습니다. 도시 이름은 표시되는데이터가 실제로 쿼리 한 도시에 속해 있는지 확인합니다. 

---

### - Displaying the data using Rxcocoa 


이미 프로젝트를 실행했다면 API에서 데이터를 검색하기 전에 앱이 데이터를 표시하는 이유를 묻고 있을 것 입니다 그 이유는 간단합니다. 수동으로 주입한 데이터가 올바른지 확인할수 있습니다. 따라서 어떤 것이 실패하면 API처리 코드의 어딘가에 있고, Rx 로직 및 UI 관련 코드가 아니라는것을 알게됩니다. 

```swift
struct Weather {
  let cityName: String
  let temperature: Int
  let humidity: Int
  let icon: String
  ...
}
```

> Note: 여기에서 struct를 사용하면 Weather생성시 모든 속성의 값이 필요하기 때문에, 보다 깨긋한 코드를 작성할수 있습니다. 값을 사용할 수 없는 경우 항상 `N/A`또는 이와 유사한 문자열을 사용할수 있습니다. 
> 

```swift
func currentWeather(city: String) -> Observable<Weather> {
  // Placeholder call
  return Observable.just(
    Weather(
      cityName: city,
      temperature: 20,
      humidity: 90,
      icon: iconNameToChar(icon: "01d"))
	) 
}
```

위의 함수는 RxCity 라는 가자 city이름을 반환하고, 더미 데이터를 디스플레이 합니다. 서버에서 실제 날시 정보를 검색 할때까지 실제 데이터 대신 사용할수 있습니다. -> 더미 데이터는 인터넷 연결이 없어도 개발 과정을 간소화하고 실제 데이터 구조처럼 작동해볼수 있도록 도와줍니다. 

결과는 단일 방향 데이터 흐름 입니다. <br>

<center><img src="/img/posts/RxCocoa.png" width="500" height="300"></center> <br> 

이전장에서 설명한 것처럼 RxSwift(더 정확하게는 Observables)는 데이터를 수신하고 모든 구독자에게 일부 데이터가 도착 했음을 알리고 처리할 값을 보낼수 있는 `entities(실체)` 입니다. 

이러한 이유로 ViewController에서 작업하는 동안 Observable의 정확한 위치는 ViewdidLoad 내부 입니다.

View가 로드된 후에 가능한 빨리 구독해야 하기 때문입니다. 

따라서 subscriptions은 application이 생성되거나, 요청한 데이터가 만들어졌거나, 유저에게 보여지기 이전에 만들어야 합니다. 

데이터를 찾아 오려면 아래의 코드를 추가해야 합니다. 

더미 데이터가 잘 디스플레이 되지만, 2가지 문제가 있습니다. 

#### - 컴파일러 경고가 있습니다.

<center><img src="/img/posts/RxCocoa-1.png" width="500" height="300"></center> <br> 

subscribe는 필요할때 구독 취소하는 일회용 객체를 반환합니다. 이 경우 구독을 취소 해야합니다

#### - 당신은 여전히 Textfield 를 입력하지 않았습니다.

```swift
let bag = DisposeBag() 
```

위의 코드를 `.disposed(by:)`를 추가한후, 추가 입력 해줍니다. 그러면 ViewController가 해제될 때마다 구독이 취소 처리 됩니다. 

이렇게하면 자원낭비를 방지할뿐만아니라, 예기치 않은 이벤트나 구독이 삭제되지 않을때 발생하는 `side-effects`를 등을 피할수 있습니다. 

첫번째 문제는 해결되었으므로 Textfield에 주의를 기울일수 있습니다. 앞서 언급 했듯이 RxCocoa는 Cocoa를 많이 추가하므로 기능을 사용하여 궁극적인 목표를 달성 할 수 있습니다.

이 프레임 워크는 Protocol exteions을 사용하고, UIKit 구성요소에`rx space`를 추가합니다. 즉 `searchCityName.rx`를 입력 하여 사용가능한 속성및 메서드를 볼수 있습니다. <br>

<center><img src="/img/posts/RxCocoa-2.png" width="500" height="300"></center> <br> 

이 함수는 `ObservableType` 및 `ObserverType`을 모두 준수하는 `ControlProperty<String?>` 인 Observable을 반환하므로 객체를 구독하고 새 값을 방출할수 있습니다. 즉 이를 통해서 새로운 구독 및 새로운 이벤트 방출 모두 가능합니다. 

`ControlProperty`의 기본 원리를 알고 있으면 코드를 개선하여 Textfield를 활용하여 더미 데이터에 도시 이름을 추가 표시 할수 있습니다. 

```swift
* ViewdidLoad 에 추가합니다.
searchCityName.rx.text
            .filter { ($0 ?? "").characters.count > 0 }
            .flatMap { text in
                return ApiController.shared.currentWeather(city: text ?? "Error")
                    .catchErrorJustReturn(ApiController.Weather.empty)
        }
        
```

위 코드는 디스플레이될 데이터가 있는 `새로운 Observable`을 반환합니다. `currentWeather`은 `nil`,`empty` 값을 허용하지 않으므로 필터링 합니다.  그런 다음 제공된 `ApiController`클래스를 사용하여 날씨 데이터를 가져옵니다.

올바른 스레드로 전환하고(UI를 다루기 때문에 MainThread 를 올바른 스레드라고 지칭하는것 같음) 데이터를 표시하여 이전 코드 블록을 계속 수행 하세요.

아래의 다이어그램은 데이터의 흐름을 이해하는데 도움이 됩니다.

<center><img src="/img/posts/RxCocoa-3.png" width="500" height="300"></center> <br> 

MainScheduler와 MainTrhead로 전환하면 모든 UIControls과 함께 있는weather data가 업데이트 됩니다. 

이 시점에서 입력을 변경할때 마다 레이블 이름이 업데이트 됩니다. 하지만 지금은 더미 데이터를 반환합니다. 응용 프로그램이 더미 데이터를 올바르게 표시한다는 것을 알고 있으므로 API에서 실제 데이터를 가져올 시간입니다.

> Note: `catchErrorJsutReturn` 연산자는 API에서 오류가 발생하면 Observable가 disposed 되는걸 막아 줍니다. 
> 
> 예를들어 잘못된 도시 이름은 `NSURLSession`에 대해서 404 오류를 반환합니다. 이 경우 오류가 발생하면 앱이 작동을 멈추지 않으려고 빈값을 반환 하려고 합니다. 

---

### - Retrieving data from the OpenWeather API

`ApiController.swift` 안에는 String(더 정확하게는 JSON에서 아이콘 데이터)을 취하고 현재의 날씨를 시각적으로 나타내는 날씨 아이콘 UTF-8 코드를 다를 String 으로 반환해주는 `iconNameToChar`라는 함수가 있습니다.

동일한 파일에는 네트워크 요청을 작성하는 편리한 함수 `buildRequest`가 있습니다. 이것은 `NSURLSession`에 대한 `RxCocoa`의 래퍼를 사용하여 네트워크 요청을 수행합니다. 해당함수는 다음을 담당합니다.

- GET(or POST) 요청을 올바르게 빌드하기 위해 기본 URL, URL 요소 추가 
- 시작부분에 생성한 API Key 사용 
- application/json으로 요청의 콘텐츠 형식 설정
- 측정 단위로 질문(단위는 캘빈)
- JSON 객체로 맵핑된 데이터 반환 

마지막 부분은 단일 return 선에 잡혀 있습니다.

```swift
return session.rx.data(request: request).map { JSON(data: $0) }
```

이것은 RxCocoa 주변의 NSURLSession의 `rx` 확장자를 사용합니다. 이것은 Observable<Data>를 리턴합니다. Observable<Data>는 raw 데이터를 JSON 타입의 SwiftJSON data구조로 변환하는데 사용되는 map 함수의 입력값으로 사용됩니다. 

일반적으로 Rx로 작업 할때는 항상 시각화 기능을 사용하는것이 좋으며, 좀 더 자세하게 업데이트 된 다이어 그램을 사용하면 ApiController 내부의 문제를 이해하는데 도움이 될것입니다.

<center><img src="/img/posts/RxCocoa-4.png" width="500" height="300"></center> <br> 

더미 데이터에서 실제 데이터 요청으로 전환하는 것은 간단합니다. `Observable.just([...])`을 실제 네트워크 요청으로 바꾸어야 합니다. OpenWeatherMap API 문서는 [http://openweathermap.org/current](http://openweathermap.org/current)를 통해 주어진 도시 이름의 현재 날씨를 요청하는 방법을 설명합니다. 

```swift
* currentWeather의 함수를 아래와 같이 변경 합니다.

func currentWeather(city: String) -> Observable<Weather> {
  return buildRequest(pathComponent: "weather", params: [("q", city)])
  .map { json in
    return Weather(
      cityName: json["name"].string ?? "Unknown",
      temperature: json["main"]["temp"].int ?? -1000,
      humidity: json["main"]["humidity"].int  ?? 0,
      icon: iconNameToChar(icon: json["weather"][0]["icon"].string ??
"e")
) }
}
```

<center><img src="/img/posts/RxCocoa-5.png" width="500" height="300"></center> <br> 

> Note: 추가로 더 가고 싶다면 `flatMap`내의 `catchErrorJsutReturn` 연산자를 제거 하십시오. 잘 못된 도시 이름으로 인해 404가 표시되면(로그에 표시됩니다) Observable이 오류로 인해 disposed 된후 응용 프로그램이 올바르게 작동하지 않을수 있습니다. 

---

## Binding observables 

Binding은 다소 논란의 여지가 있습니다. 예를들어 Apple 는 iOS에 바인딩 시스템인 Cocoa Bindings을 공개하지 않았습니다(비록 오랫동안 macOS의 중요한 부분 이었더라도)

mac바인딩은 매우 진보적이고, macOS SDK의 특정 Apple 제공 클래스와 너무 얽혀 있습니다. 

RxCocoa는 프레임 워크에 포함된 몇가지 유형에만 의존하는 다소 간단한 솔루션을 제공합니다. 

RxSwift 코드로 이미 마음이 편하기 때문에, 바인딩을 신속하게 처리할수 있습니다. 

여기에서 중요한점은 RxCocoa에서 바인딩은 `단방향 데이터 스트림(undirectional stream of data)` 이라는것 입니다. 이것은 데이터의 흐름을 크게 단순화 하기때문에, 책에서는 `양방향 바인딩을 다루지(bi-directional bindings)` 않습니다.

---

### - What are binding observables?

binding을 쉽게 이해하려면 두개의 연결된 객체간의 관계를 생각해보면 됩니다. <br>

<center><img src="/img/posts/RxCocoa-6.png" width="500" height="300"></center> <br> 

- A producer는 값을 제공합니다
- A receiver는 producer의 값을 처리합니다.

receiver는 값을 반환할수 없습니다. 이것은 RxSwift에서 binding을 사용할때 일반적인 규칙입니다. <br>

<center><img src="/img/posts/RxCocoa-7.png" width="500" height="300"></center> <br> 

> Note: 나중에 데이터 모델 속성과, 텍스트 필드 사이에서 양방향 바인딩(bi-directional bindings)을 실험하려는 경우 두개의 preoducers, 두개의 receiver가 포함된 4개의 객체(entities)를 사용하여 모델을 만들수 있습니다. 이것은 상상할수 있듣이 코드의 복잡성을 상당히 증가 시킵니다. 

바인딩의 기본 기능은 `bind(to:)` 이며, `observable이 다른 객체에 바인드`하려면 `receiver가 ObserverType`를 준수해야합니다.

이전 장에서 entity는 설며되었으며, 그것(Subject)은 값을 처리할수 있습니다. 또한 수동으로 작성할수도 있습니다. 

`Subjects`는 UILabel, UITextField, UIImageView 등과 같은 기본 구성 요소가 set, get 할수 있는 변경 가능한 데이터를 가지고 있다는것을 고려하여 `코코아의 필수 특성을 다루는데 매우 중요합니다`.

또한 `bind(to:)`는 사용자 인터페이스를 데이터의 기초에 바인드 하는것 뿐만 아니라, 다른 목적으로도 사용될수 있다는것을 기억해야합니다. 

예를들어 bind(to:)를 사용하여 종속 프로세스(dependent processes)를 만들수 있으므로,  observable이 화면에 표시된 내용을 다루지 않고 일부 백그라운드 작업을 수행하는 대상을 트리거 하기도 합니다.

**요약하자면, bind(to:) 함수는 subscribe() 함수의 특수한 맞춤형 버전이고 bind()를 호출할때 부작용(side effect)나 특별한경우는 없습니다.**

---

### - Using binding observables to display data 

바인딩이 무엇인지 알게 되었으니, 바인딩을 앱에 통합할수 있습니다. 이 과정에서 전체 코드를 좀더 우아하게 만들고 검색 결과를 재사용 가능한 데이터 소스로 변환 할 것입니다.

첫번째 변경 사항은 `subscription(onNext:)`를 사용하여 올바른 UILable에 데이터를 할당하는 long observable객체를 리펙터링 하는것입니다.

ViewController.swift를 열고, viewDidLoad()에서 searchCityName의 전체 subscribe코드를 다음으로 바꿉니다.

```swift
let search = searchCityName.rx.text
  .filter { ($0 ?? "").characters.count > 0 }
  .flatMapLatest { text in
    return ApiController.shared.currentWeather(city: text ?? "Error")
        .catchErrorJustReturn(ApiController.Weather.empty)
  }
  .shareReplay(1)
  .observeOn(MainScheduler.instance)
```

특히 `flatMapLatest`는 검색 결과를 재사용 가능하게 만들고 일회용 데이터 소스를 다중 사용 가능한 Observable로 변환합니다. 이렇게 변형 하면서 얻은 장점은 추후 MVVM에서 다룰것입니다. 

Observable은 Rx의 재사용 가능한 entity가 될수 있음을 쉽게 알수 있습니다. 

올바른 모델링을 사용하면 길고 읽기가 어려운 일회용 observable가 될수 있습니다. 대신 다중사용 및 이해하기 쉬운 관찰자로 전환하십시오.

<center><img src="/img/posts/RxCocoa-8.png" width="500" height="300"></center> <br> 

이 작은 변화로 다른 subscribe에 모든 단일 매개변수를 처리하고 표시해야하는 값을 매핑할수 있습니다. 예를 들어, Observable은 공유 데이터 소스에서 온도를 문자열로 얻는 방법은 다음가 같습니다. 

```swift
search.map{ "\($0.temperature)° C}"
```

그러면 온도로 표시될수 있는 문자열을 반환하는 observable이 생성됩니다. 첫번째 바인딩을 만들려면 `bindTo`를 사용하여 원본 데이터 소스를 온도 레이블에 연결 하십시오.

```swift
// temperature binding
search.map {"\($0.temperature)° C"}
	.bind(to: tempLabel.rx.text)
	.disposed(by: bag)
        
// iconLabel binding
search.map { $0.icon }
	.bind(to:iconLabel.rx.text)
	.disposed(by:bag)
        
// humidity binding
search.map { "\($0.humidity)%" }
	.bind(to:humidityLabel.rx.text)
	.disposed(by:bag)
        
// cityName binding
search.map { $0.cityName }
	.bind(to:cityNameLabel.rx.text)
	.disposed(by:bag)
```

이제 application이 observable이 single source observable을 사용하여 서버에서 요청한 데이터를 표시하고 화면의 각 레이블에 다른 데이터 조각을 바인딩 합니다. 

<center><img src="/img/posts/RxCocoa-9.png" width="500" height="300"></center> <br> 

---

### Improving the code with Traits 

`RxCocoa`는 `bindTo`와 `Cocoa`가 함께 사용되도록 독점적으로 생성된 observables의 특별한 구현들을 넘어서고 있습니다. `Traits`

`RxCocoa`는 Cocoa 및 UIKit을 사용하여 보다 쉽게 작업할수 있는 고급 기능을 제공합니다. `BindTo`이외에도 UI와 함께 사용하도록 독점적으로 생성된 Observable의 특수 구현을 제공합니다. 

`Units`은 클레스의 그룹입니다. 특히 UI로 작업할때 코드 작성및 단순화가 용이 합니다. <br>

[https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md](https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md) <br>

---

### What are Control Property and Drive?

`Traits`은 공식문서에 다음과 같이 기술됩니다. 

> `Traits` also help communicate and ensure observable sequence properties across interface boundaries
> 
> `Traits`은 Observable seqeunce 객체가 인터페이스 영역과 소통할수 있도록 도와줍니다.(???)

개념적으로 어려울수 있지만, 이러한 특성에 적용된 규칙은 전체 개념을 이해하기 쉽게 만듭니다.

- Traits은 오류를 발생시키지 않습니다.
- Traits은 Main scheduler에서 observed 합니다.
- Traits은 Main scheduler에서 subscribe 합니다.
- Traits은 부작용(side effect)을 공유합니다.

이러한 entities는 사용자 인터페이스에 항상 표시되는 항목과 사용자 인터페이스에서 처리 할 수 있는 올바른 방법으로 항상 처리되는지 확인하기 위해 만들어 졌습니다.

`Traits` 프레임워크의 두가 주요 구성요소는 다음과 같습니다.

- ControlProperty and ControlEvent
- Driver 

`ControlEvent`는 새로운것이 아닙니다. rx 확장을 사용하여 올바른 사용자 인터페이스 구성요소에 데이터를 바인딩하기 위해 얼마전에 사용했습니다.

`ControlEvent`는 텍스트 필드를 편집하는 동안 키보드의 **Return**버튼을 누르는 것과 같이 UI 구성요소의 특정 이벤트를 수신하는데 사용됩니다. 구성요소가 

`ControlEvent`는 구성요소가 `UIControlEvents`를 현재 상태에 계속 두고 사용할 때 가능 합니다. 

`Driver`은 이전에 설명된 것과 동일한 제약사항으로 인해 오류를 발생시키지 않습니다. 모든 프로세스가 mainThread 에서 실행되도록 보장되므로 background-Thread 에서UI룰 변경하지 않아도 됩니다. 

`Traits`은 일반적으로 프레임워크의 선택적인 부분이므로 사용하지 않아도 됩니다. `observables`, `subjects`만 자유롭게 사용하여 올바른 schecuder, 올바른 task에서 작업을 수행하고 있는지 확인 하세요. 그러나 컴파일 하는동안 몇가지 검사를 하고 UI를 처리할때 좋은 제한이 필요한 경우 이 구성요소들은 매우 강력하고 시간을 절약 합니다. 

.observeOn(MainSchduler.instance)를 호출하고 background-Thread 에서 UI 에 관한 프로세스를 수행하는 경우가 드물지 않습니다. 

`Drive`와 `ControlProperty`가 혼란 스러울지라도 걱정하지 마십시오. 예제 코드에 들어가면 더 이해하기 쉽습니다. 

---

### - Improving the project with Driver and ControlProperty 

어떤 개념이 끝나면, 올바른 Thread에서 작동하는지, 아무것은 애러를 방출하는지, 받은 결과로 부터 구독이 멈추는지를 확인해야합니다. 

첫번째 step은 weather data observable을 driver로 변경하는것 입니다. 

```swift
* ViewDidload 에서 검색 상수를 정의하는 곳을 찾고 다음과 같이 변경합니다.

let search = searchCityName.rx.text
  .filter { ($0 ?? "").characters.count > 0 }
  .flatMapLatest { text in
    return ApiController.shared.currentWeather(city: text ?? "Error")
        .catchErrorJustReturn(ApiController.Weather.empty)
  }
  .asDriver(onErrorJustReturn: ApiController.Weather.empty)
```

여기에서 핵심코드는 `.asDriver(...)` 입니다. `observable`을 `Driver`로 변경합니다. `onErrorJustReturn` 매개변수는 obserable이 에러를 발출할때 어떻게 할것인지에 대한 기본값을 정의하고 있습니다. 그러므로 driver는 스스로 방출된 에러를 떼어내는게 가능합니다.(?)

또한 자동완성기능이 asDriver(onErrorJsutReturn)에 다른 변형을 제공한다는 사실을 눈치 챘을 것 입니다. 

- asDriver(onErrorDriveWith:)함수를 사용하면 오류를 수동으로 처리가 가능하고, 이 목적으로 생성된 새로운 sequence를 만들수 있습니다. 

- asDriver(onErrorRecover): 또 다른 Driver(onErrorDrive 대신에 onErrorRecover)와 함께 사용할수 있습니다. 현재 Driver가 에러를 받았을때 복구할 목적으로 사용할수 있습니다. 

`Driver`에 대해 `bindTo`가 없으므로 응용 프로그램이 빌드되지 않습니다.  Driver가 bindTo처럼 비슷하게 작동하는 녀석을 찾아야합니다.

```swift
search.map { "\($0.temperature)° C" }
	.drive(tempLabel.rx.text)
	.disposed(by: bag)
search.map { $0.icon }
	.drive(iconLabel.rx.text)
	.disposed(by: bag)
search.map { "\($0.humidity)%" }
	.drive(humidityLabel.rx.text)
	.disposed(by: bag)
search.map { $0.cityName }
	.drive(cityNameLabel.rx.text)
	.disposed(by: bag)
```

이렇게하면 드라이버의 기능을 활용하면서 application의 올바른 UI동작이 복원됩니다. `Drvier`는 `bindTo`와 아주 비슷하게 작동합니다. `Unit`을 사용하는 동안 이름의 차이가 의도를 더 잘 표현합니다.

Application은 너무 많은 리소스를 사용하고 너무 많은 API 요청을 합니다. 문자를 입력할 때마다 요청이 발생하기 때문입니다. 너무 낭비라고 생각하지 않습니까?

```swift
* let search = searchCityName.rx.text 를 찾아서 아래처럼 바꾸어봅니다

let search = searchCityName.rx.controlEvent(.editingDidEndOnExit).asObservable()
            .map { self.searchCityName.text }
            .flatMap { text in
                return ApiController.shared.currentWeather(city: text ?? "Error")
            }
            .asDriver(onErrorJustReturn: ApiController.Weather.empty)
```

검색 버튼을 누를때만 날씨를 검색하고 네트워크 요청합니다. 또한 currentWeather(city:)가 반환한 observable에 대한 catchErrorJustReturn()호출을 제거했습니다.

> 대신 이렇게 바꾸게 되면, 검색결과가 error을 방출하게 되면 error에 대한 UI는 변경 하지만, observable은 dispose 됩니다. 이것을 해

<center><img src="/img/posts/RxCocoa-10.png" width="500" height="300"></center> <br> 


원래의 계획은 전체 UI를 업데이트하는 하나의 observable을 사용했습니다. 여러 블록의 분석을 통해 subscribe 에서 bindTo로 전환합니다!

---

## Disposing with RxCocoa 

시작부분에서 설명했듯이 ViewController가 해제될때 모든 subscribe의 dispose를 관리하기 위한 것이었다. 그런데 왜 `weak` 나 `unowned` 키워드를 클로저 내부에 사용하지 않는걸까?

대답은 간단합니다. 해당 application은 단일 ViewController 이며, application이 동작되는 동안 mainViewController 는 항상 스크린에 보여집니다. 그래서 보관주기 동안 메모리 낭비를 막을 필요가 없었습니다.

---

### - unowned vs weak with RxCocoa

Cocoa로 RxCocoa, RxSwift를 다룰때 `weak`, `unowned`를 언제 사용하는지 어려울수 있습니다. 

현재 object가 이미 방출된 어떤 시점에서 closure를 호출할수 있을때 `weak`를 사용했습니다. 이런 이유로 self는 선택 사항(Optional)이 됩니다. 그러나 클로저가 호출되기 전에 개체가 해제 되지 않도록 해야합니다. 그렇지않으면 app이 죽어버립니다. 

RxSwift에서 특히 RxCocoa에서, `weak`, `unowned`에 선택에 대한 좋은 가이드라인이 있습니다. 

- **nothing**: 내부의 singletons, ViewController (root ViewController 같은)

- **unowend**: 클로저 작업이 수행된 후에 해제되는 모든 뷰컨트롤러의 내부

- **weak**: 위의 두 상황을 제외한 모든 경우 

이러한 기본 규칙은 `EXC_BAD_ACCESS error` 오류를 방지합니다. 안전을 더 중욯게 생각한다면 raywenderlich.com swift가이드 라인이 있습니다.

[https://github.com/raywenderlich/swift-style-guide#extending-object-lifetime](https://github.com/raywenderlich/swift-style-guide#extending-object-lifetime)

---

## Where to go from here?

이 장에서 RxCocoa를 소개했습니다. RxCocoa는 실제로 큰 프레임 워크입니다. RxCocoa의 일부분만 보았지만 이것이 좋은 토대가 될것입니다. 

이 프레임 워크에 32개의 확장을 사용할수 있따는 점을 감안할때 몇가지 예를 살펴 보는것이 좋습니다. 

- UIActivityIndicatorView: UIActivityIndicatorView는 가장 많이 사용되는 UIKit 구성 요소중 하나입니다. 해당 확장 프로그램에는 다음과 같은 속성을 사용할수 있습니다.

```swift
public var isAnimating: UIbindingObserver<base, Bool>
```

이름에서 알수 있듯이 이녀석은 `isAnimating`과 관련이 있습니다. UILabel에서 처럼 이 객체는 `UIBindingObserver`타입으로 결과는 observable 객체에 바인딩 되어 `background`활동에 대해 통지할수 있습니다.

- UIProgressView: UIProgressView는 덜일반적인 구성요소이지만 RxCocoa에서도 다루며 다음과 같은 속성을 사용합니다

```swift
public var progress: UIBindingObserver<Base, Float>
```

```swift
let progressBar = UIProgressBar()
let uploadFileObs = uploadFile(data: fileData)
uploadFileObs.map { sent, totalToSend in
    return sent / totalToSend
  }
  .bind(to:progressBar.rx.progress)
  .disposed(by:bag)
```

UIProgressBar를 observable객체에 바인딩할수 있습니다. 예를들어 uploadFile()함수가 서버에 파일을 업로드하는 작업을 observable객체를 통해서 바이트 와 총 바이트 값을 제공한다고 가정하면. 위의 코드 처럼 작성할수 있습니다.

결과는 ProgressBar의 값이 파일업로드 상황을 말해줍니다. 

---

## Challenges

스위치를 이용해서 섭씨(℃)를 화씨(℉)로 바꾸기 

여기서의 도전과제는 섭씨를 화씨로 바꾸는 것이다. 해결방법은 여러가지가 될수 있다. 

- API Request를 미터법(metric)에서 야드 파운드법(imperial)로 바꾸자
- 섭씨값을 수학적인 방법을 통해 화씨로 매핑할수 있다. `temperature * 1.8 + 32`

기술적으로 상기 해결법들은 각각의 장애물들을 가지고 있다. 

- 첫번째 방법은 ApiController.swift의 subject를 변경 하여야 한다
- 두번째는 짧고 간단할수 있다. 이는 search observable을 UISwitch의 control객체와 합치는 방식으로 해결 할수 잇다. 

### - 첫번째 방법 

request 를 화씨값으로 받아오면됩니다! 

```swift
let unitsQueryItem = URLQueryItem(name: "units", value: "imperial")
```

### - 두번째방법

```swift
        let textSearch = searchCityName.rx.controlEvent(.editingDidEndOnExit).asObservable()
        let temperature = switcher.rx.controlEvent(.valueChanged).asObservable()
        let search = Observable.of(textSearch,temperature)
            .merge()
            .debug()
            .map { self.searchCityName.text }
            //.filter { ($0 ?? "").characters.count > 0 }
            .flatMap { text in
                return ApiController.shared.currentWeather(city: text ?? "Error")
                    // 해당 함수에서 발생한 에러를 처리하지 못하면 Observable가 죽음..
                    .catchErrorJustReturn(ApiController.Weather.empty)
            }
            .asDriver(onErrorJustReturn: ApiController.Weather.empty)
```

```swift
search.map { city -> String in
            if self.switcher.isOn {
                return "\(Int((Double(city.temperature) * 1.8) + 32))"
            }else {
                return "\(city.temperature)° C"
            }
            }
            .drive(tempLabel.rx.text)
            .disposed(by: bag)
```

2개의 비동기적인 데이터 흐름을 하나로 묶어서, 처리했음.. 호호.. Rx의 장점이 여기에서 두드러지게 보여지는것 같습니다.


---

## Reference 

* 공식 

[http://reactivex.io](http://reactivex.io/documentation/ko/observable.html) <br> 
[Introduce to Rx](http://www.introtorx.com/Content/v1.0.10621.0/00_Foreword.html) <br>
[RxJS Marbles](http://rxmarbles.com/) <br>
[RxSwift github](https://github.com/ReactiveX/RxSwift) <br>
[http://community.rxswift.org/](http://community.rxswift.org/) <br>


* 개인 참조 

[Raywenderlich Swift Guideline](https://github.com/raywenderlich/swift-style-guide#extending-object-lifetime) <br>
[https://github.com/devminjun/RxSwift_Practice](https://github.com/devminjun/RxSwift_Practice)

* Traits 

[reactive-single](http://reactivex.io/documentation/single.html) <br>
[https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md](https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md) <br>
[https://brunch.co.kr/@tilltue/33](https://brunch.co.kr/@tilltue/33) <br>

---
