---
layout:     post
title:      "RxSwift. 기초 정리하기 (13)"
subtitle:   "Creating Custom Reactive Extension"
date:       2018-03-18 20:01:00
author:     "MinJun"
header-img: "img/tags/RxSwift-bg.jpg"
comments: true 
tags: [RxSwift, RxCocoa]
---

Raywenderlich-Ebook의 RxSwift를 읽고 정리한 내용입니다.

---

## RxCocoa 정리 (13) 

- Creating custom Reactive Extension 
- Getting started
- How to create extension 
	- How to extend URLSession with `.rx`
	- How to create wrapper methods
	- How to create custom operators 
- Use custom wrappers
- Testing custom wrappers 
	- How to write tests for custom wrappers 
- Common available wrappers
	- RxDataSource
	- RxAlamofire
	- RxBluetoothKit
- Where to go frome here?
- Challenge 1: Add processing feedback 
- Reference

---

## Creating custom Reactive Extension 

`RxSwift`, `RxCocoa`에 대해 소개하고 테스트를 만드는 방법을 배우고 나면 `Apple`나 타사에서 만든 프레임 워크 위에 `RxSwift`를 사용하여 Extension을 만드는 방법을 아직 알지 못했습니다,

Apple, 다른 프레임워크의 구성 요소를 래핑하는것은 `RxCocoa`에 대한 장에서 소개 되었으므로 해당 장의 프로젝트를 진행하면서 학습을 확장하것입니다. 

이장에서는 `NSURLSession`에 대한 확장을 생성하여 endPoint와 Application의 일부인 캐시 및 기타 사항을 관리합니다. 

이것은 교육상의 예입니다. Network로 RxSwift를 사용하고 싶다면 `RxAlamofire`를 다루는 내용이 이 책에 포함되어 있습니다. 

---

## Getting started 

시작하려면 웹에서 인기있는 GIF 서비스중 하나인 [https://giphy.com](https://giphy.com)에서 beta key가 필요합니다. 

beta key를 얻으려면 [https://github.com/Giphy/GiphyAPI](https://github.com/Giphy/GiphyAPI)로 이동하세요.

개발중에 사용할수 있는 공유된 beta key이므로 사용중 제한이 있을수 있습니다.

`ApiController.swift`를 열고 키를 올바른 위치로 복사 하십시오. 


```swift
apiKey = "[YOUR KEY]"
```

API KEY를 입력하고, pod 파일을 인스톨하고 프로젝트 시작을 준비합니다. 

---

## How to create extension 

`Cocoa` 클래스나 프레임워크를 통해 Extension을 생성하는 것은 사소한 작업 처럼 보일수 있습니다. 해당 프로세스가 약간 까다로울수도 있고, 이전의 선행 과정을 요구할수도 있습니다. 

여기서 목표는 `URLSession`을 `rx`네임 스페이스로 확장하고 `RxSwift` extension을 분리하고 여러분(또는 팀) 이하 클래스를 extension하고 충돌을 방지하는것입니다. 

---

### How to extend URLSession with `.rx`

`URLSession`에 `.rx` 확장자를 사용하려면 URLSession + Rx.swift를 열고 다음을 추가하십시오.

```swift
extension Reactive where Base: URLSession {
}
```

`Reactive` extension은 매우 영리한 프로토콜을 통해 `.rx` 네임 스페이스를 노출 합니다. 

이것은 `RxSwift`로 `URLSession`을 확장 하는 첫번째 단계입니다. 이제 실제 `wrapper`을 만들 차례입니다. 

---

### How to create wrapper methods 

`NSURLSession`에 `.rx`네임 스페이스르 노출했으므로, 이제 노출할 데이터 유형의 Observable을 반환하는 레퍼된 함수를 만들수 있습니다. 

API는 다양한 유형의 데이터를 반환 할수 있으므로 앱에서 예상하는 데이터 유형을 확인하는것이 좋습니다. 

다음 유형의 데이터를 처리하기 위한 레퍼를 만드려고합니다. 

- Data: 단순한 데이터
- String: 텍스트로된 데이터
- JSON: JSON 객체의 인스턴스
- Image: 이미지의 인스턴스

이러한 레퍼는 예상하는 유형이 안전하게 전달하는것을 기대할수 있습니다. 

이 래퍼는 모든 다른것들을 만드는데 사용됩니다. 그 하나는 `HTTPURLResponse`, `Data`를 결과로 반환합니다.

이제 당신의 목표는 `Observable<Data>`를 가지고 나머지 세 연산자를 생성하는것입니다.<br>

<center><img src="/img/posts/RxSwift_Extension.png" width="500" height="300"></center> <br> 

```swift
func response(request: URLRequest) -> Observable<(HTTPURLResponse, Data)> { 
return Observable.create { observer in
    // content goes here
    return Disposables.create()
  }
}
```

주요 response 함수의 골격을 만들기를 시작합니다. 그리고 무엇을 반환하는지 압니다. 다음 코드를 방금 만든 Extension이 있는곳에 추가합니다.

```swift
func response(request: URLRequest) -> Observable<(HTTPURLResponse, Data)>
{
  return Observable.create { observer in
    // content goes here
    return Disposables.create()
  }
}
```

이 함수가 무엇을 반환하는지 명확합니다. `URLResponse`는 요청이 성공적으로 처리 되었는지 확인하기 위해 검사하는 부분이며 Data는 요청에 의한 실제 반환된 데이터 입니다. 

`URLSession`은 콜백(callbacks) 과 작업(task)을 기반으로 합니다. 예를 들어 요청을 보내고 서버 응답을 수신하는 내장 매소드는 `dataTask(with: completionHandler:)`입니다. 

이 함수는 콜백을 사용하여 결과를 관리하므로 observable의 논리를 observable내의 클로져에서 관리해주어야 합니다.

이렇게 하려면 `Observable.create` 내부에 다음을 추가하십시오.

```swift
let task = self.base.dataTask(with: request) { (data, response, error) in
}
task.resume()
```

생성된 task는 다시시작(또는 시작) 해야하하므로 `resume()`함수는 요청을 트리거합니다.

그 결과 콜백에 의해 적절하게 처리됩니다.

> Note: `resume()`함수의 사용은 `Impreative Programming(명령적 프로그래밍)`이라고합니다. 나중에 이것이 무엇을 의미하는지 정확하게 알수 있습니다. 
> 

작업이 완료 되었으므로 진행하기 전에 수행할 변경 사항이 있습니다. 

이전 블록에서 `Disposable.create()`를 반환 했습니다. Observable이 삭제된 경우 아무 작업도 수행하지 않습니다. 

리소스를 낭비하지 않도록 요청을 취소하는것이 좋습니다. 이렇게 하려면 `Disposable.create()`를 다음으로 대체하십시오

```swift
return Disposables.create(with: task.cancel)
```

`Observable`에 올바른 평상 전략을 얻었으니 이제 이 인스턴스에 이벤트를 보내기 전에 데이터가 올바르게 반환되는지 확인해야 합니다.

이를 위해 `task.resume()`바로 위 closure에 다음을 추가하세요 

```swift
guard let response = response, let data = data else {
  observer.on(.error(error ?? RxURLSessionError.unknown))
return
}
guard let httpResponse = response as? HTTPURLResponse else {
  observer.on(.error(RxURLSessionError.invalidResponse(response: response)))
return
}
```

위의 guard 문은, 구독을 알리기전에 요청이 성공적으로 수행되었음을 확인합니다. 

요청이 올바르게 완료 되었는지 확인한 후 이 observable에 일부 데이터가 필요합니다. 위에서 추가한 코드 바로 위(above) 라니까 아랫라인에 다음 코드를 추가합니다.

```swift
observer.on(.next(httpResponse, data))
observer.on(.completed)
```

이것은 모든 subscriptions(구독자들)에게 이벤트가 전송되고 즉시 완료 됩니다. 

요청과 응답을 실행하고 응답을 받는 것은 단일 사용법(single usage Observable) 입니다. 

observable이 살아있는 상태를 유지하고 다른 요청을 수행하는것은 이치에 맞지 않습니다.(RxSwift의 장점중 하나는 비동기 코드들을 순차적으로 받을수 있는것중 하나가 위배되서 그런것같음..?) 이는 소켓 통신과 같은 것에 더 적합합니다. 

이것은 `URLSession`을 래핑하는 가장 기본적인 연산자 입니다. Application이 올바른 종류의 데이터를 처리하는지 확인하기 위해 몇가지 사항을 추가로 포장해야합니다.

좋은 소식은 이 메소드를 재사용하여 나머지 편리한 메소드르 빌드 할수 있다는 것입니다. 

먼저 Data 인스턴스를 반환하는 인스턴스를 추가합니다. 

```swift
func data(request: URLRequest) -> Observable<Data> {
        return response(request: request).map{ (response, data) -> Data in
            if 200 ..< 300 ~= response.statusCode {
                return data
            } else {
                throw RxURLSessionError.requestFailed(response: response, data: data)
            }
        }
    }
```

`Data observable`은 다른 모든것의 근원 입니다. `Data`는 String, JSON object or UIImage로 변환할수 있습니다. 

`String`를 반환하는 함수를 추가합니다.

```swift
func string(request: URLRequest) -> Observable<String> {
        return data(request: request).map { d in
            return String(data: d, encoding: .utf8) ?? ""
        }
    }
```

JSON data 작업하기 쉬운 구조이므로 전용 변환이 필요없습니다.

```swift
func json(request: URLRequest) -> Observable<JSON> {
  return data(request: request).map { d in
    return JSON(data: d)
  }
}
```

마지막으로 `UIImage`를 반환하는 함수를 추가합니다.

```swift
    func image(request: URLRequest) -> Observable<UIImage> {
        return data(request: request).map { d in
            return UIImage(data: d) ?? UIImage()
        }
    }
```

방금 한것처럼 extension을 모듈화하면 더 나온 조합이 가능합니다. 

예를 들어 마지막 observable은 다음과 같이 시각화 할수 있습니다. <br>

<center><img src="/img/posts/RxSwift_Extension-1.png" width="500" height="300"></center> <br> 

map, 그리고 일부 `RxSwift`연산자는 진행시 오버해드를 피하기 위해 현명하게 되합되어 map의 다중 체인이 단일 호출로 최적화됩니다. 

그것들을 연결하거나 클로저에 너무 많은 것을 포함하는것에 대해 걱정하지 마십시오.

---

### How to create custom operators 

`RxCocoa`에 대한 장에서 데이터를 캐시하는 함수를 만들었습니다.

일부 `GIF`의 크기를 고려할때 이 방법은 좋은 접근방법 입니다. 또한 좋은 Application은 로딩 시간을 가능한 최소화 해야합니다. 

이 경우 좋은 접근법은 (HTTPURLResponse, Data) 유형의 observable에 대해서만 사용할수 있는 데이터를 캐시하기 위한 특수 연산자를 만드는것입니다. 

이 목표는 `cache`를 가능하게 하는 것이므로 (HTTPURLResponse, Data)의 Observable 이벤트에 대해서만 이 연산자를 만들고 요청에 절대 URL(absolute URL)을 검색하고 응답을 사용하여 dictionay의 키로 사용하는 것이 합리적입니다.(캐시의 사용목적)

캐싱전략은 간단한 `Dictionary`가 될것입니다. 나중에 이 본 동작을 확장하여 캐시를 유지하고 Application을 다시 열때 다시 로드할수 있지만 현재 프로젝트 범위를 벗어납니다. 

상단의 `RxURLSessionError`정의 앞에 Cache Dictionary 를 만듭니다. 

```swift
fileprivate var internalCache = [String: Data]()
```

only observable의 Data타입을 타겟하기 위한 extension을 만듭니다.

```swift
extension ObservableType where E == (HTTPURLResponse, Data) {
}
```

이 extension 내에서 다음과 같이 cache()함수를 만들수 있습니다. 

```swift
func cache() -> Observable<E> {
  return self.do(onNext: { (response, data) in
    if let url = response.url?.absoluteString, 200 ..< 300 ~=
response.statusCode {
      internalCache[url] = data
    }
}) 
```

캐시를 사용하려면 response을 캐시하기 위해 데이터 data(reqeust:)의 return 문을 수정해야합니다.(예를 들어 `.cache()`부분만 삽입 할수 있습니다. 


```swift
return response(request: request).cache().map { (response, data) -> Data
in
//...
}
```

데이터가 이미 사용 가능한지 확인하려면 매번 네트워크 요청을 실행하는 대신 반환하기 전에 다음을 데이터 (data(reqeust:)함수 맨위에 추가하십시오

```swift
if let url = request.url?.absoluteString, let data = internalCache[url] {
  return Observable.just(data)
}
```

이제 특정 유형의 캐싱 시스템만 확장하는 매우 기본적인 캐싱 시스템을 갖게 되었습니다. <br> 

<center><img src="/img/posts/RxSwift_Extension-2.png" width="500" height="300"></center> <br> 


매우 일반적인 솔루션이라고 생각하면 다른 종류의 데이터를 캐시하는데 동일한 절차를 다시 사용할수 있습니다. 

---

## Use custom wrappers 

특정 observable 유형만 타켓팅하는 사용자 지정 연산자는 `URLSession`주위에 래퍼를 만들었습니다.

이제 결과를 가져오고 재미있는 고양이 `GIF`를 보여줄 차례입니다. 

현재 프로젝트에는 이미 도구들이 포함되어 있으므로 `Giphy API`에서 제공되는 `JSON`구조 목록만 제공하면됩니다. 

`ApiController.swift`를 열고 `search()`메소드를 살펴 보세요.

내부 코드는 `Giphy API`에 대한 적절한 요청을 준비하지만, 맨래에서는 네트워크 호출을 하지 않지만 대신 빈 observable을 반환합니다(이것은 placeholder code 입니다.)

이제 `URLSession` reactive 확장을 완료했으므로 이를 사용하여 맞춤형 방법으로 네트워크에서 데이터를 가져올수 있습니다. `return`문을 다음과같이 수정하세요

```swift
return URLSession.shared.rx.json(request: request).map() { json in
  return json["data"].array ?? []
}
``` 

주어진 쿼리 문자열에 대한 요청을 처리하지만 데이터는 여전히 화면에 표시되지 않습니다.

실제로 화면에 `GIF`가 표시되기 전에 수행해야할 마지막 단계가 있습니다. 

`GifTableViewCell.swift`에 `downloadAndDisplay(gif stringUrl:):` 끝에 다음을 추가하세요 .

```swift
let s = URLSession.shared.rx.data(request: request)
  .observeOn(MainScheduler.instance)
  .subscribe(onNext: { imageData in
      self.gifImageView.animate(withGIFData: imageData)
    self.activityIndicator.stopAnimating()
  })
disposable.setDisposable(s)
```

일을 잘 수행하기 위해서는 `SingleAssignmentDisposable()`을 반드시 사용해야 합니다. 

`GIF` 다운로드가시작되면 사용자가 스크롤하여 이미지 렌더링을 기다리지 않으면 중지되었는지 확인해야 합니다. 

이것을 올바르게 균형잡기 위해서는 `prepareForReuse()`에 다음 두 행이 있습니다.(이미 시작 코드에 포함되어 있으므로 지금 입력할 필요가 없습니다.)

```swift
disposable.dispose()
disposable = SingleAssignmentDisposable()
```

`SingleAssignmentDisposable()`을 사용하면 모든 단일 셀에 대해 주어진 시간에 하나의 구독만 유지되므로 리소스를 흘릴일이 없습니다. <br>

<center><img src="/img/posts/RxSwift_Extension-3.png" width="500" height="300"></center> <br> 

---

## Testing custom wrappers 

모든것이 제대로 작동하는 것처럼 보이지만 특히 타사 프레임 워크를 래핑하고 몇가지 테스트를 만들고 코드를 더 개발할때 모든 것이 올바르게 작동하는지 확인하는것이 좋은 습관입니다. 

`Test Suites`는 프레임워크 주변의 래퍼가 올바른 모양으로 유지되도록 하며, 변경 또는 버그로 인해 코드가 실패한 부분을 찾는데 도움이 됩니다.

---

### How to write tests for custom wrappers 

이전 장에서 테스트를 시작했습니다. 이 장에서 레퍼 `RxNimble`과 함께 `Nimble`이라는 Swift에서 테스트를 작성하는데 사용되는 공통 라이브러리를 사용합니다. 

`RxNimble`은 테스트를더 쉽게 작성하고 코드를 간결하게 도와줍니다. 고전적으로 사용하는 대신에

```swift
let result = try! observabe.toBlocking().first()
expect(result) != 0
```

위의 코드를 짧게 작성할수 있습니다.

```swift
expect(observable) != 0
```

`iGifTests.swift`테스트 파일을 엽니다. section에서 `Nimble`, `RxNimble`, 네트워크 요청을 스텁하는데 사용되는 `OHHTTPStub`및 비동기 작업을 blocking 하는데 필요한  `RxBlocking`을 볼수 있습니다. 

파일의 끝에는 단일 함수로 `BlockingObservable`에 대한 간단한 확장을 찾을수 있습니다. 

```swift
func firstOrNil() -> E? {}
```

이것은 남용하는 시도를 피하는것인가요? 곳 확인해볼것입니다.

파일의 맨위에는 다음과 같이 테스트 할 미비 JSON 객체가 있습니다. 

```swift
let obj = ["array": ["foo", "bar"], "foo": "bar"] as [String: Any]
```

위 처럼 미리 정의된 데이터를 사용하면 `Data`, `String`, `JSON` 테스트를 더 쉽게 작성할수 있습니다.

첫번째 테스트는 데이터 요청에 대한 테스트 입니다. 

다음 코드를 테스트 클레스 케이스에 추가하여 `nil`을 반환하지 않는지 확인합니다.

```swift
func testData() {
  let observable = URLSession.shared.rx.data(request: self.request)
  expect(observable.toBlocking().firstOrNil()) != nil
}
```

버튼을 클릭하고 테스트를 실행하세요. 테스트가 성공하면 버튼이 녹색으로 변경됩니다. 실패하면 빨간색으로 변경됩니다. 모든코드를 올바르게 입력했다면 녹색체크 표시로 바뀝니다.

원래 데이터가 JSON 표현임을 고려하고 키 정렬 방식을 고려할때 예상되는 결과는 다음과 같습니다.

```swift
{"array":["foo","bar"],"foo":"bar"}
```

이 테스트는 정말 간단합니다. 다음을 추가하여 JSON 문자열을 이스케이프 한다는 사항을 고려합니다.

```swift
func testString() {
  let observable = URLSession.shared.rx.string(request: self.request)
  let string = "{\"array\":[\"foo\",\"bar\"],\"foo\":\"bar\"}"
  expect(observable.toBlocking().firstOrNil()) == string
}
```

이 테스트에는 비교할 JSON 데이터 구조가 필요합니다. 문자열 버전을 Data로 변환하고 JSON으로 처리하려면 다음 코드를 추가하세요.

```swift
func testJSON() {
  let observable = URLSession.shared.rx.json(request: self.request)
  let string = "{\"array\":[\"foo\",\"bar\"],\"foo\":\"bar\"}"
  let json = JSON(data: string.data(using: .utf8)!)
  expect(observable.toBlocking().firstOrNil()) == json
}
```

마지막 테스트는 오류가 제대로 반환되는지 확인하는 것입니다. 두 오류를 비교하는 것은 드문 절차이므로 오류에 대해 동등한 연산자를 사용하는 것은 이치에 맞지 않습니다. 

따라서 테스트에서는 `do-try-catch`를 사용해야 하며 알수 없는 오류를 잡으려고해야합니다.

```swift
func testError() {
  var erroredCorrectly = false
  let observable = URLSession.shared.rx.json(request: self.errorRequest)
  do {
    let _ = try observable.toBlocking().first()
    assertionFailure()
  } catch (RxURLSessionError.unknown) {
    erroredCorrectly = true
  } catch {
    assertionFailure()
  }
  expect(erroredCorrectly) == true
}
```

이 시점에서 프로젝트가 완료됩니다. `URLSession`위에 고유한 extension기능을 만들었으며 랩퍼가 제대로 작동하는지 확인하는 멋진 테스트를 만들었습니다. 

Apple 프레임 워크와 다른 ㅅ써드파티 프레임 워크는 주요 릴리즈의 변경 사항을 깨기 때문에 매우 중요합니다. 따라서 테스트가 중단되고 래퍼가 작동을 멈추면 빠르게 행동할 준비가 되어있어야합니다.(다르게 릴리즈 되었을때 빠르게 대처할수 있게 테스트 코드를 통해서 확인)

---

## Common available wrappers 

`RxSwift`커뮤니티는 매우 적극적이며 많은 extension과 래퍼가 이미 있습니다. 일부는 Apple 구성 요소를 기반으로하고 일부는 많은 iOS 및 macOS 프로젝트에서 널리 사용되는 타사 라이브러리를 기반으로 합니다. 

최신 래퍼 목록은 [http://community.rxswift.org](http://community.rxswift.org) 에서 찾을수 있습니다. 

다음은 현재 가장 일반적인 래퍼에 대한 간략한 개요 입니다. 

---

### RxDataSource 


`RxDataSources`는 `RxSwift`의 `UITableView` 및 `UICollectionView` 데이터 소스로서 다음과 같은 몇가지 훌륭한 기능을 제공합니다. 

- 차이들을 계산하기 위한 `O(N)` 알고리즘(??)
- 최소 개수의 명령을 절단된 뷰로 보내는 경험적방법(??)
- 이미 구현된 뷰 extension 지원 
- 계층적 에니메이션 지원 

이것들은 모두 중요한 기능이지만 가장 좋아하는것은 두개의 데이터소스를 구별하는 O(N) 알고리즘 입니다. 

Application이 TableView를 관리할때 불필요한 계산을 수행하지 않도록 도와줍니다.

내장된 `RxCocoa`테이블 바인딩을 사용하여 작성한 코드를 살펴보십시오

```swift
let data = Observable<[String]>.just(
  ["1st place", "2nd place", "3rd place"]
)
data.bindTo(tableView.rx.items(cellIdentifier: "Cell")) { index, model,
cell in
  cell.placeLabel.text = model
}
.disposed(by:disposeBag)
```

이것은 간단한 데이터 세트로 완벽하게 작동하지만 애니메이션이 부족하고 여러 색션을 지원하며 확장되지 않습니다. 

`RxDataSource`를 올바르게 설계하면 코드가 더욱 강력해집니다. 

```swift
//configure sectioned data source
let dataSource =
RxTableViewSectionedReloadDataSource<SectionModel<String, String>>()
Observable.just([SectionModel(model: "Position", items: ["1st", "2nd",
"3rd"])])
  .bindTo(tableView.rx.items(dataSource: dataSource))
  .disposed(by: disposeBa
```

그리고 미리 수행해야 하는 데이터 소스의 최소 구성은 다음과 같습니다.

```swift
dataSource.configureCell = { dataSource, tableView, indexPath, item in
  let cell = tableView.dequeueReusableCell(
    withIdentifier: "Cell", for: indexPath)
  cell.placeLabel.text = item
  return cell
}
dataSource.titleForHeaderInSection = { dataSource, index in
  return dataSource.sectionModels[index].header
}
```

TableView 와 CollectionView의 바인딩은 중요한 작업이기 때문에 책의 뒷부분에서 자세히 살펴볼것입니다.

---

### RxAlamofire 

`RxAlamofire`는 우아한 Swift HTTP 네트워킹 라이브러리 `Alamofire`를 둘러싼 래퍼입니다. 

`Alamofire`는 가장 널리 사용되는 프레임워크중 하나입니다. 

`RxAlamofire`에는 다음과 같은 편리한 확장 기능이 있습니다.

```swift
func data(_ method:_ url:parameters:encoding:headers:)
  -> Observable<Data>
```

이 방법은 모든 요청의 세부 사항을 하나의 호출로 결합한 다음 서버 응답을 `Observable<Data>`로 반환합니다. 

또한 도서관에서는 다음을 제공합니다.

```swift
func string(_ method:_ url:parameters:encoding:headers:)
  -> Observable<String>
```

이것은 `Content`응답의 `Observable`을 `String`으로 반환합니다.

또한 그 만큼 중요한것은 

```swift
func json(_ method:_ url:parameters:encoding:headers:)
  -> Observable<Any>
```

이것은 객체의 인스턴스를 반환합니다. 

이 메소드가 이전에 작성한 것과 같은 `JSON object`를 리턴하지 않는다는 것을 아는 것이 중요합니다. 

이 외에도 `RxAlamofire`에는 파일을 다운로드 하거나 업로드 하고 진행 정보를 검색 할수 있는 observable 기능을 만드는 편리한 기능이 포함되어 있습니다. 

---

### RxBluetoothKit 

`BlueTooth`로 작업하는 것은 복잡할수 있습니다. 일부 호출은 비동기식이며 호출 순서는 장치나 주변 장치에서 데이터를 올바르게 연결하고 데이터를 보내고 받는데 중요합니다.

`RxBluetoothKit`은 `Bluetooth`로 작업할때 가장 고통스러운 부분을 추상화하고 몇가지 멋진 기능을 제공합니다.

- `CBCentraManager` 지원 
- `CBPeripheral` 지원
- `sharing`, `queueing` 스캔

`RxBluetoothKit`사용을 시작하려면 manager를 만들어야합니다. 

```swift
let manager = BluetoothManager(queue: .main)
```

주변 장치를 검색하는 코드는 다음 행을 따라 표시됩니다.

```swift
manager.scanForPeripherals(withServices: [serviceIds])
.flatMap { scannedPeripheral in
  let advertisement = scannedPeripheral.advertisement
}
```

추가로 연결합니다.

```swift
manager.scanForPeripherals(withServices: [serviceId])
  .take(1)
  .flatMap { $0.peripheral.connect() }
  .subscribe(onNext: { peripheral in
      print("Connected to: \(peripheral)")
  })
```

또한 매니저의 현재 상태를 observe 하는것도 가능합니다

```swift
manager.rx_state
  .filter { $0 == .poweredOn }
  .timeout(1.0, scheduler)
  .take(1)
  .flatMap { manager.scanForPeripherals(withServices: [serviceId]) 
  }
```

관리자 외에도 특성 및 주변 장치에 대한 매우 편리한 추상화가 있습니다. 

예를 들어 주변 장치에 연결하려면 다음을 수행할수 있습니다.

```swift
peripheral.connect()
  .flatMap { $0.discoverServices([serviceId]) }
  .subscribe(onNext: { service in
      print("Service discovered: \(service)")
  })
```

특성(characteristic)을 발견하고 싶다면 

```swift
peripheral.connect()
  .flatMap { $0.discoverServices([serviceId]) }
  .flatMap { $0.discoverCharacteristics([characteristicId])}
  .subscribe(onNext: { characteristic in
      print("Characteristic discovered: \(characteristic)")
  })
```

또한 `RxBluetoothKit`에는 연결 복원을 올바르게 수행하고 `Bluetooth`상태를 모니터링하며 단일 주변 장치의 상태를 모니터링하는 기능이 있습니다.

---

## Where to go frome here?

이장에서 Apple 프레임 워크를 래핑하고 구현하는 방법을 봤습니다. 가끔 `RxSwift`와 더 잘 연결하기 위해 공식 Apple 프레임워크 또는 타사라이브러리를 추상화하는것이 매우 유용합니다. 

추상화가 필요한 시점에 대한 실질적인 문서 작성 규칙은 없지만 프레임 워크가 다음 조건 중 하나 이상을 충족하는 경우 이 전략을 사용하는 것이 좋습니다.

- 완료 및 실패 정보가 있는 콜백을 사용합니다.
- 많은 대리자를 사용하여 정보를 비동기적으로 반환합니다.
- 프레임워크는 기존의 RxSwift와 상호작용 가능해야합니다. 

또한 프레임워크가 데이터를 처리해야하는 스레드에 대한 제한 사항이 있는지 알아야 합니다.

이러한 이유로 `RxSwift`래퍼를 만들기 전에 설명서를 철저히 읽는 것이 좋습니다. 

기존 커뮤니티 확장을 찾는것을 잊지 마십시오. 작성한 것이라면 커뮤니티와 다시 공유하는것을 고려하십시오!(ㅎㅎ)

---

## Challenge 1: Add processing feedback 

이 과제에서 JSON 및 UIImage 처리에 대한 정보를 추가해야 합니다. 

현재 상태에서 데이터를 처리할수 없을때 응요 프로그램은 빈 문자열 또는 이미지를 받습니다. 

잠시 시간을 내어 코드를 검토하고 기본 빈 객체를 제거하고 유형 변환이 제대로 수행되지 않으면 코드에서 오류를 발생 시키십시오. 

`URLSession+Rx.Swift`의 `RxURLSessionError`열거형에는 `deserializationFailed`라는 사례가 이미 포함되어 있습니다. 유형 변환이 실패할때 예외를 던집니다.

시작하기 전에 이것이 언제 어디에서 제기되어야 하는지 이해하려고 노력하십시오.

observable 항목에 오류를 보내는 것은 종료이므로 올바른 대소 문자로 오류를 보내고 있는지 확인하십시오.

```swift
public func json(request: URLRequest) -> Observable<JSON> {
        return data(request: request).map { d in
            let json = try JSON(data: d)
            if json.object is NSNull {
                throw RxURLSessionError.deserializationFailed
            }
            return json
        }
    }
    
    public func image(request: URLRequest) -> Observable<UIImage> {
        return data(request: request).map { d in
            if let image = UIImage(data: d) {
                return image
            } else {
                throw RxURLSessionError.deserializationFailed
            }
        }
    }
```

---

## Reference 

* 공식 

[http://reactivex.io](http://reactivex.io/documentation/ko/observable.html) <br> 
[Introduce to Rx](http://www.introtorx.com/Content/v1.0.10621.0/00_Foreword.html) <br>
[RxJS Marbles](http://rxmarbles.com/) <br>
[RxSwift github](https://github.com/ReactiveX/RxSwift) <br>
[http://community.rxswift.org/](http://community.rxswift.org/) <br>


* 개인 참조 

[https://giphy.com](https://giphy.com)<br>
[https://github.com/Giphy/GiphyAPI](https://github.com/Giphy/GiphyAPI)<br>
[https://github.com/AliSoftware/OHHTTPStubs](https://github.com/AliSoftware/OHHTTPStubs)<br>
[https://github.com/ReactiveX/RxSwift/tree/master/RxTest](https://github.com/ReactiveX/RxSwift/tree/master/RxTest)<br>
[https://github.com/Quick/Nimble](https://github.com/Quick/Nimble)<br>
[https://github.com/RxSwiftCommunity/RxNimble](https://github.com/RxSwiftCommunity/RxNimble)<br>

---




