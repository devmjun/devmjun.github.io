---
layout:     post
title:      "RxSwift. 기초 정리하기 (1)"
subtitle:   "Observable, Operators, Schedulers, App Architecture, RxCocoa, PublishSubject, BehaviorSubject, ReplySubject, Variable.."
date:       2018-02-25 14:00:00
author:     "MinJun"
header-img: "img/tags/RxSwift-bg.jpg"
comments: true 
tags: [RxSwift]
---

Raywenderlich-Ebook의 RxSwift를 읽고 정리한 내용입니다.

---


## RxSwift 정리 (1) 

- RxSwift 란?
	- Observables
	- Operators
	- Schedulers
	- App Architecture
	- RxCocoa
- Observables
	- Lifecycle of an observable 
	- Creating observables 
	- Subscribing to observables
	- Empty, never, range
	- Disposing and terminating
	- Creat
- Subjects
	- publishSubject
	- BehaviorSubject
	- ReplaySubject
	- Variable
- Reference 

---

## RxSwift 란?

RxSwift is a library for composing `asynchronous` and event-based code by using `observable sequences` and `functional style operators`, allowing for parameterized execution via schedulers

비동기 코드를 간결하게 작성하게 해주는, 함수형 프로그래밍 패러다임을 사용하는 확장팩..


```swift
RxSwift = ReactiveX + Swift
			  ReactiveX = Reactive + Extenstion 

반응형 프로그래밍을 하기위해 ReactiveX가 사용하는 도구
	- Observer Pattern
	- Iterator Pattern
	- Functional Programming 
```

- 비동기 코드의 핵심 문제점 
	- 작업의 테스트가 실행 되는 순서를 보장할수 없음
	- 변경 가능한 데이터의 공유 순서를 보장할수 없음 
	- Side Effects(부작용): 함수 스코프를 벗어나서 바깥 세상에 변화를 가하는 행동(네트워크, 상태변경, I/O)

```swift
override func viewDidAppear(_ animated: Bool) {
  super.viewDidAppear(animated)
  setupUI()
  connectUIControls()
  createDataSource()
  listenForChanges()
}

위의 코드들의 실행순서와, 어떤속성들을 변경하는지 알수없음. 이러한 요소들로 인해서, 앱이 생각처럼 동작하지 않을수 있습니다. 
```

---

### Observables 

- Observable<T> class는 Rx code의 기초입니다. 변경 불가능한 스냅샷 값을 연속적으로 시간의 흐름에 따라서 방출 합니다. 
- ObservableType protocol(Observable<T>의 클레스를 따릅니다)는 간다하고, 3가지 type의 이벤트 유형만 방출할수 있습니다. 

- `next`: 최신(또는 다음) 데이터값을 전송하는 이벤트 입니다. 
- `completed`: 해당이벤트는 성공한 이벤트 시퀀스를 종료합니다. Observables이 생명 주기를 성공적으로 완료 했으며 다른 이벤트를 발생 시키지 않는다는 것을 의미합니다
- `error`: 오류가 방출되고 오류로 인해서 이벤트가 종료되고 이후 다른 이벤트가 발생하지 않습니다. <br>

<center><img src="/img/posts/RxSwiftInRaywnerlich.png" width="700" height="350"></center> <br> 

<center><img src="/img/posts/RxSwiftInRaywnerlich-1.png" width="700" height="350"></center> <br> 

### - 예제

iOS앱 에서 인터넷에서 파일을 다운로드 하는 경우를 보면 

- 첫번째로 먼저 다운로드 시작하는 데이터를 관찰합니다
- 그 다음 파일의 일부가 들어오고 난 이후에 연속적으로 들어오는 데이터 뭉치를 관찰합니다.
- 인터넷연결이 끊어지면 다운이 중지되고, 연결시간이 초과되어 에러와 함께 인터넷 연결이 끊깁니다. 
- 또는 모든 파일의 데이터 코드가 다운로드 되면 성공적으로 완료됩니다.

```swift
* 실제 작동하지 않는 가상의 코드 입니다.

* case 1 
API.download(file: "http://www...")
  .subscribe(onNext: { data in
    ... append data to temporary file
  },
  onError: { error in
    ... display error to user
  },
  onCompleted: {
    ... use downloaded file
  })
  
* case 2 
UIDevice.rx.orientation
  .subscribe(onNext: { current in
    switch current {
      case .landscape:
        ... re-arrange UI for landscape
      case .portrait:
        ... re-arrange UI for portrait
    }
})
```

- Infinite observable sequences: 자연적으로 종료될것으로 예상되는 값이 아닌, UI업데이트, 디바이스 방향에 따른 레이아웃 변경 등등이 있습니다, 사실상 무한가디 떄문에 Observable 사용시 항상 `초기값`을 가지고 있어야합니다

---

### Operators

ObservableType 와 Observable class는 비동기 작업을 추상화 하는 많은 메서드가 포함되어 있습니다. Operator은 주로 비동기 입력을 받아, Side Effect(부작용) 없는 값을 제공합니다. 

예를 들어서 `(5 + 6) * 10 - 2`의 연산을 한다고하면 이전에 정의한 연산자들 `*, ( ), + and -` 을 가져와서 Observable의 방출되는 값에 적용하고 결과를 출력할수 있습니다. <br>

<center><img src="/img/posts/RxSwiftInRaywnerlich-3.png" width="500" height="300"></center> <br> 

```swift
* 작동하지 않는 가상의 코드 입니다.
UIDevice.rx.orientation
  .filter { value in
    return value != .landscape
  }
.map { _ in
    return "Portrait is the best!"
  }
  .subscribe(onNext: { string in
    showAlert(text: string)
  })
``` 

여러가지 연산자를 구성이 가능합니다. 항상 데이터를 받고, 가져와서 결과를 출력하므로 단일 연산자로 수행할수 있는 것보다 훨씬 많은 작업을 여러가지 방법으로 쉽게 할수 있습니다.

---

### Schedulers

Schedulers are the Rx equivalent of dispatch queues — just on steroids and much easier to use.

- Rx Scheduler는 99%의 해당하는 케이스를 커버하고 있어서 사용자가 Scheduler를 만들 필요가 없다
- 예를 들어, GDC의 Scheduler에서 GDC를 사용하여 주어진 큐에서 코드 실행을 직렬화하는 이벤트를 관찰하도록 지정할 수 있습니다.
- Concurrent Dispatch Queue Scheduler의 Operation Queue Scheduler를 사용하여 NSOperationQueue에서 Subscribe 순서를 지정할수 있습니다.
- 다른 Scheduler위에 있는 동일한 여러개의 Scheduler 작업을 추가하여 최고의 성능을 얻을수 있습니다(?) <br>

<center><img src="/img/posts/RxSwiftInRaywnerlich-4.png" width="700" height="350"></center> <br> 

---

### App Architecture 

- RxSwift는 앱의 아키텍처를 어떤식으로든 변경하지 않습니다. Event, asynchronous data sequences, 그리고 범용 통신 프로토콜을 주로 처리 합니다. 
- MVC로 Rx 애플리케이션을 만들수 있습니다. 원하는 경우 MVP, MVVM을 선택할수 있습니다. 그렇다면 단방향 데이터 아키텍처를 구현하는데 유용한 도구가 될수 있습니다.

- MVVM이 RxSwif와 잘 어울리는 이유: ViewModel은 Observable<T> Properties를 노출 할수 있으며, View Controller glue code속에 있는 UIKit controls 에 직접적으로 바인딩할수 있습니다. 이렇게 하면 모델 데이터를 UI에 바인딩하고 코드를 작성하는것이 매우 간단해집니다. 한마디로 Observable 되는 값을 UI에 직접적으로 바인딩해서 사용이 가능해지고 그렇게 사용하는 코드가 RxSwift를 사용했을때 사용하지 않았을떄보다 간결해진다는 뜻!?

<center><img src="/img/posts/RxSwiftInRaywnerlich-5.png" width="700" height="350"></center> <br> 

---

### RxCocoa

RxSwift는 Rx API의 구현체 입니다. 따라서 Cocoa 또는 UIKit의 특정 클레스에 대해서 알지 못할수도 있습니다. 하지만 UIKit, Cocoa의 개발을 지원하는 거의 모든 클래스를 지원합니다. 

- 예시

```swift
toggleSwitch.rx.isOn
  .subscribe(onNext: { enabled in
    print( enabled ? "it's ON" : "it's OFF" )
  })

Switch의 상태 변환(on, off)일때 출력되는 값을 설정
```

<center><img src="/img/posts/RxSwiftInRaywnerlich-6.png" width="700" height="350"></center> <br> 

---

## Observables 

Observables은 Rx의 심장입니다. `observable`, `observable sequence`, and `sequence` 등을 서로 바꾸어서 부르기도 합니다. 하지만 그들은 모두 똑같습니다. 때로는 다른 Reactive Programming을 사용하다 RxSwift를 사용하는 개발자들은 `Stream` 이라고 부르기도 하지만, RxSwift 에서는 `sequence` 입니다.

가장 중요한것은 `비동기` 입니다. Observables은 일정 기간동안 이벤트를 생성하고 이것을 emit(방출)합니다. 이벤트는 숫자, 커스텀 유형의 인스턴스 또는 탭과 같은 동작이 인식될수 있습니다. 

<center><img src="/img/posts/RxSwiftInRaywnerlich-7.png" width="700" height="350"></center> <br> 

---

### Lifecycle of an observable

Observable은 이벤트가 종료되면 `completed event`라고 부릅니다. 

<center><img src="/img/posts/RxSwiftInRaywnerlich-8.png" width="700" height="350"></center> <br> 
<center><img src="/img/posts/RxSwiftInRaywnerlich-9.png" width="700" height="350"></center> <br> 

이 대리석 다이어그램에서 오류가 발생했습니다. 관측 대상에서 오류가 포함 된 오류 이벤트가 발생했습니다. 관측 대상이 완료된 이벤트로 정상적으로 종료 될 때와 다를 바 없습니다. 관측 가능 이벤트가 오류 이벤트를 발생 시키면 종료되고 더 이상 다른 이벤트를 방출 할 수 없습니다.
다음은 간단한 요약입니다.

- Observable은 다음 중 한가지가 실행 될때까지 이벤트를 방출합니다.
	- `.error` 이벤트를 방출하고 종료합니다
	- `.completed` 이벤트를 방출하고 종료합니다.
	- Observable이 종료되면 더이상 이벤트를 방출할수 없습니다. <br>

```swift
/// Represents a sequence event.
///
/// Sequence grammar:
/// **next\* (error | completed)**
public enum Event<Element> {
    /// Next element is produced.
    case next(Element)
    /// Sequence terminated with an error.
    case error(Swift.Error)
```

---

### Creating observables 

- 예제 

```swift
var one = 1
var two = 2
var three = 3

var observer = Observable.just(one)
var observer1 = Observable.of(one, two, three)
var observer2 = Observable.of([one, two, three])
var observer3 = Observable.from([one, two, three])
var observer4 = Observable.from(one, two, three) // 컴파일 에러

observer.subscribe { print($0) } // next(1) -> completed
observer1.subscribe { print($0) } // next(1) -> next(2) -> next(3) -> completed
observer2.subscribe { print($0) } // next([1, 2, 3]) -> complted
observer3.subscribe { print($0) } // next(1) -> next(2) -> next(3) -> completed
observer4.subscribe { print($0) } // 컴파일 에러
```

---


### Subscribing to observables

iOS 개발자는 NotificationCenter에 익숙할수 있습니다. RxSwift는 Observer에서 Noti를 보냅니다. 

아래의 예제는 UIKeyboardDidChangeFrame notification의 사용 예시입니다. RxSwift와 어떻게 다른지 찾아봅니다.

```swift
let observer = NotificationCenter.default.addObserver(
  forName: .UIKeyboardDidChangeFrame,
  object: nil,
  queue: nil
) { notification in
  // Handle receiving notification
}
let sequence = 0..<3
var iterator = sequence.makeIterator()
while let n = iterator.next() {
  print(n)
```

RxSwift의 관찰은 Notification과 비슷합니다. 따라서 addObserver() 대신에 subscribe()을 사용합니다. NotifcationCenter는 개발자가 .default인스턴스를 사용하는데, RxSwift는 각 관찰 대상이 다릅니다.

더 중요한것은 Observer는 Subscribe가 있을때 까지 이벤트를 보내지 않습니다. 관찰 대상은 실제로 `sequence definition` 라는것을 기억해야합니다. `Observable을 Subscribe 하는것은 Swift의 Iterator에서 next()를 호출하는것과 같습니다.` <br>

```swift
observer3.subscribe { event in
    if let element = event.element {
        print(element) // 1 2 3 
    }
}

observable3.subscribe(onNext: { element in
  print(element) // 1 2 3 
})
	-> .next 요소만 사용하고 나머지는 무시합니다. 

event 에는 속성값들이 있습니다. 해당 속성값들을 하나씩 확인후 출력해보시길 권장합니다!
```

subscribe의 return 값을 `disposeBag` 입니다. `disposeBag`에 대해서는 뒤에서 배우도록 합니다!

---

### Empty, never, range

Observer가 관찰 항목을 유추할수 없는 경우, 특정 유형으로 정의해야합니다.

#### - Empty 

```swift
let observable = Observable<Void>.empty()
let x = observable
    .subscribe(
        onNext: { (element) in
            print(element)
    },
        onCompleted: {
            print("completed")
    })
```

onCompleted 이벤트만 출력하는것을 확인할수 있습니다. empty는 의도적으로 제로값을 반환받기를 원할때 사용하면 유용합니다.

#### - never

never 연산자는 아무것도 방출하지 않고, 결코 종료하지 않는 Observerble 만듭니다. 무한의 지속시간에서 사용되는곳에서 사용할수 있습니다.

아직 어디에 어떻게 사용되는지 감이 오지도않음.. 

```swift
let observable = Observable<Any>.never()
observable
	.subscribe(
		onNext: { element in
				print(element)
        },
		onCompleted: {
				print("Completed")
        })

``` <br>

해당 코드를 작성하면, 아무것도 출력하지 않음. 그렇다면 실행이 되었는지는 어떻게 확인할수 있을까? <br>


```swift
public func example(of description: String, action: () -> Void) {
    print("\n--- Example of:", description, "---")
    action()
}

example(of: "never") {
    let observable = Observable<Any>.never()
    observable
        .subscribe(
            onNext: { element in
                print(element)
        },
            onCompleted: {
                print("Completed")
        }
    )
}
--- Example of: never --- 출력되는것을 확인할수 있음. 실행되는데 아무것도 출력을 하지않음.. 뭐지..
```

#### - range

```swift
let observable = Observable<Int>.range(start: 1, count: 10)
observable
    .subscribe(onNext: { i in
        // 2
        let n = Double(i)
        let fibonacci = Int(((pow(1.61803, n) - pow(0.61803, n)) /
            2.23606).rounded())
        print(fibonacci)
    })
```

---

### Disposing and terminating

Observable은 .error, .completed 이벤트를 받으면 종료합니다. Observable를 수동으로 종료시킬수 있습니다.

```swift
* case 1
let observable = Observable.of("A", "B", "C")
let subscription = observable.subscribe { event in
    print(event)
}
subscription.dispose() -> 사실 이렇게 명시적으로 Observable을 종료 시키는 방법은 좋지 않습니다. 

* case 2
// 1
  let disposeBag = DisposeBag()
// 2
  Observable.of("A", "B", "C")
    .subscribe { // 3
print($0) }
    .disposed(by: disposeBag) // 4
```

- Observables의 사용이 끝나면 메모리를 해제해야 합니다. 그 때 사용할 수 있는것이 Dispose입니다. RxSwift에서는 DisposeBag을 사용하는데 DisposeBag instance의 deinit() 이 실행 될 때 모든 메모리를 해제합니다.  <br>

#### Creat

```swift
let disposeBag = DisposeBag()
    Observable<String>.create { observer in
        return Disposables.create()
    }
```

- Creat는 subscribe라는 단일 매개 변수를 사용하고 observable의 subscribe를 호출을 구현하게 만드는것이 목적입니다. 방출될 모든 이벤트를 정의합니다. option키를 누르고 확인해줍니다.
- create 연산자는 subscribe(AnyObserver)라는 단일 매개 변수를 사용하고 Disposable을 반환하는 @escaping 클로져 입니다. 그 임무는 observable에 subscribe를 호출하는 구현을 제공하는 것입니다. 즉, 가입자에게 방출 될 모든 이벤트를 정의합니다. 옵션 - 생성을 클릭하십시오.

```swift
Observable<String>.create { observer in
  // 1
  observer.onNext("1")
  // 2
  observer.onCompleted()
// 3
  observer.onNext("?")
// 4
  return Disposables.create()
}
```

위의 코드에서 "?"가 실행되는지 알수 없습니다.

```swift
let disposeBag = DisposeBag()
Observable<String>.create { observer in
    // 1
    observer.onNext("1")
    // 2
    observer.onCompleted()
    // 3
    observer.onNext("?")
    // 4
    return Disposables.create()
    }.subscribe(
        onNext: { print($0) }, // 1
        onError: { print($0) },
        onCompleted: { print("Completed") }, // Complted
        onDisposed: { print("Disposed") } // Disposed
    )
    .disposed(by: disposeBag)

* 수정 

enum MyError: Error {
    case anError
}

let disposeBag = DisposeBag()
Observable<String>.create { observer in
    // 1
    observer.onNext("1")
    // 2
    //observer.onError(MyError.anError) -> 주석 처리를 해제하면서 출력되는결과를 확인해봅시다!
    //observer.onCompleted()
    // 3
    observer.onNext("?")
    // 4
    return Disposables.create()
    }.subscribe(
        onNext: { print($0) }, // 1
        onError: { print($0) },
        onCompleted: { print("Completed") }, // Complted
        onDisposed: { print("Disposed") } // Disposed
    )
    .disposed(by: disposeBag)

```

#### Creating observable factories

observable가 subscribe를 기다리는것보다, 새로운 observable factories를 만들수 있습니다. 

```swift
let disposeBag = DisposeBag()
// 1
var flip = false
// 2
let factory: Observable<Int> = Observable.deferred {
    // 3
    flip = !flip
    // 4
    if flip {
        return Observable.of(1, 2, 3)
    } else {
        return Observable.of(4, 5, 6)
    }
}
for _ in 0...3 {
    factory.subscribe(onNext: {
        print($0, terminator: "")
    })
        .disposed(by: disposeBag)
    print()
}

123
456
123
456
```

deferred의 파라미터가 `observableFactory` 입니다!, terminator에 어떤 기능을 넣으면, Observable마다 실행합니다.

---

#### .debug

.subscribe 하기전에, .debug 함수를 실행하면, 콘솔창에 작동 흐름이 찍힘.. 디버깅에 도움 됩니다. <br>

```swift
let observable = Observable<Any>.never()
    let disposeBag = DisposeBag()
    observable
        .debug()
        .subscribe(
            onNext: { element in
                print(element)
        },
            onCompleted: {
                print("Completed")
        },
            onDisposed: {
                print("Disposed")
        })
        .disposed(by: disposeBag)
```

#### do

<center><img src="/img/posts/RxSwiftInRaywnerlich-10.png" width="700" height="350"></center> <br> 

```swift
observable
    .do(onSubscribe: {
        print("Subscribed")
    })
    .subscribe(
        onNext: { element in
            print(element)
    },
        onCompleted: {
            print("Completed")
    },
        onDisposed: {
            print("Disposed")
    })
    .disposed(by: disposeBag)
```

---

## Subjects

observable, obserer 하는것

RxSwift는 4가지의 Subjects가 있습니다. 

- publishSubject: 비어있는값(초기화값이 없음)으로 시작하고, subscribe에게만 새로운 요소를 방출합니다
- BehaviorSubject: 초기값으로 시작하여(초기값이 있음) 새로운 subscribe에게 최신 요소를 재 생성후 반환합니다(reply)
- ReplaySubject: buffer size로 초기화되고, 최대 크기까지 buffer 요소를 유지하고 새로운 subscribe에게 재 생성후 반환합니다.
- Variable: BehaviorSubject를 래핑하고 현재값을 유지하고, 최신/초기 값만 새로운 subscribe에게 재생합니다(현재 Variable대신 BehaviorSubject를 사용하라고 RxSwift에서 권장합니다.)
	- 해당 내용은 [https://git.io/vNqvx](https://git.io/vNqvx) 에서 참고할수 있습니다. 

---

### PublishSubject 

PublishSubject는 subscribe가 구독 취소시점, 완료된, .error 이벤트로 종료될떄까지 구독자가 구독한 시점부터 새로운 이벤트를 받지 원할때 유용합니다.

<center><img src="/img/posts/RxSwiftInRaywnerlich-11.png" width="700" height="350"></center> <br> 


```swift
let subject = PublishSubject<String>()
subject.onNext("is anyone listening?")

let scriptionOne = subject.subscribe { (string) in
    print(string)
}

subject.on(.next("1")) // next(1)
subject.onNext("2") // next(2)
	-> on(.next("1")과 .onNext("2")는 같은 일을 합니다. 
```

- 예제 

```swift
    let subject = PublishSubject<String>()
    subject.onNext("is anyone listening?") // 구독 scription 이전이라 호출이안됨. -> 여기에서 Publishsubject의 특징을 알수 있습니다. Publishsubject는 현재 구독하고 있는 구독자에게만 현재값을 전달합니다.
    subject.on(.next("is anyone"))

    let scriptionOne = subject.subscribe {
        print($0)
        
    }

    subject.on(.next("1")) // next(1)
    subject.onNext("2") // next(2)


    let subscrptionTwo = subject.subscribe { event in
        print("2)", event.element ?? event)
    }

    subject.on(.next("3")) // 2) 3
    subject.onNext("4") // 2) 4
```

사실 subject type는 일단 종료되면, 향후 구독자에게 중지 이벤트를 다시 방출합니다. PublishSubject의 가장큰 특징은, 초기화 값이 없고, 현재 구독하고 있는 구독자에게만 새로운 요소만(only new elements)을 전달한다는 것입니다! 

---

### BehaviorSubjects 

BehaviorSubject는 PublishSubject와 비슷하게 작동합니다. 단 마지막 값을 반복하는것을 제외하고, 초기값이 있다는 점이 다릅니다. BehaviorSubject는 항상 최신의 값만 방출하므로 초기값이 존재해야 사용할수 있습니다.

<center><img src="/img/posts/RxSwiftInRaywnerlich-12.png" width="700" height="350"></center> <br> 

```swift
let subject = BehaviorSubject(value: "Initial value") // 초기값이 있음.
    let disposeBag = DisposeBag()
    
    subject
        .subscribe {
            print(label: "1)", event: $0) // 1) Inital value
        }
        .disposed(by: disposeBag)
    subject.onNext("X") // 1) X
    subject.onError(MyError.anError) // 1) anError
    
    subject
        .subscribe {
        print(label: "2)", event: $0) // 2) anError
    }.disposed(by: disposeBag)
```

---

### ReplaySubjects

ReplySubjects는 선택한 크기까지 방출되는 최신 요소를 일시적을 캐시하거나 버퍼링(buffering) 할수 있습니다. 그리고 새로운 구독자에게 재 생성후 반환합니다.

메모리에 저장되어있는 ReplySubject를 사용할때는 조심해야합니다. 이미지와 같이 큰 버퍼(buffer)을 차지하는것을 사용할때, 배열을 사용할떄 조심해야합니다. 방출된 요소는 Array가 되기 떄문에, buffer size는 많은 Array의 buffer가 됩니다. 해당 사항을 조심하지 않으면 memory에 부하가 갈수 있습니다. <br>

<center><img src="/img/posts/RxSwiftInRaywnerlich-13.png" width="700" height="350"></center> <br> 

```swift
// 1
    let subject = ReplaySubject<String>.create(bufferSize: 2)
    let disposeBag = DisposeBag()
    // 2
    subject.onNext("1")
    subject.onNext("2")
    subject.onNext("3")
    
    subject
        .subscribe {
            print(label: "1)", event: $0) // 1) 2 -> 1) 3
        }
        .disposed(by: disposeBag)
    
    subject
        .subscribe {
            print(label: "2)", event: $0) // 2) 2 -> 2) 3
    }
    
    subject.onNext("4")

    subject
        .subscribe {
            print(label: "3)", event: $0) // 3) 3 -> 3) 4
        }
        .disposed(by: disposeBag)
    
    subject.onError(MyError.anError) // 1) anError -> 2) anError -> 3) anError
    subject.dispose() // Object `RxSwift.ReplayMany<Swift.String>` was already disposed -> 라고 3.4 버전에서는 출력되는것 같은데. 4.0 버전에서는 아무일도 일어나지않음..
```

---

## Variables

앞에서 언급했듯이 Variables 은 Behavior Subject를 래핑하고, 현재값을 state로 저장합니다. 

`value` 프로퍼티를 통해서 현재 값에 접근할수 있고, 일반적으로 subject와 observables와 달리 해당 value 속성을 사용하여 새 요소를 변수에 설정합니다. `즉 onNext(_:)를 사용하지 않아도 됩니다.`

behavior subject를 래핑한 값이 초기값으로 만들어지고, 최신또는 초기값을 새 구독자에게 reply(재생)합니다. 변수의 기동 동작에 접근하면 `asObservable()`을 호출합니다.

다른 주제와 다른 점은 오류를 표시하지않는 점입니다. 따라서 Variables에 대한 subscription 에서 .error 이벤트를 수신 할 수는 있지만, .error 이벤트를 Variable에 추가할수 없습니다. 

Variable의 할당이 해제될때 자동으로 완료되므로 실제로 .complted 이벤트를 추가하지 않습니다(실제로 할수 없습니다)

```swift
    var variable = Variable("Initial value")
    let disposeBag = DisposeBag()

    variable.value = "New initial value"
    
    variable.asObservable()
        .subscribe {
            print(label: "1)", event: $0) // 1) New initial value
    }.disposed(by: disposeBag)
    
    variable.value = "1"
    variable.asObservable()
        .subscribe {
            print(label: "2)", event: $0) // 1) 1 -> 2) 1
    }.disposed(by: disposeBag)
    
    variable.value = "2"
    
    // 아래는 현재 컴파일 되지 않음.
    variable.value.onError(MyError.anError)
    variable.asObservable().onError(MyError.anError)
    variable.value = MyError.anError
    variable.value.onCompleted()
    variable.asObservable().onCompleted()
```

---


## Reference 

* 공식 

[http://reactivex.io](http://reactivex.io/documentation/ko/observable.html) <br> 
[Getting Started Rxswift](https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#observables-aka-sequences) <br>
[Introduce to Rx](http://www.introtorx.com/Content/v1.0.10621.0/00_Foreword.html) <br>
[RxJS Marbles](http://rxmarbles.com/) <br>
[RxSwift github](https://github.com/ReactiveX/RxSwift) <br>
[http://community.rxswift.org/](http://community.rxswift.org/) <br>



* 일반참고 

[RxSwift 시작하기 전수열님](https://www.slideshare.net/devxoul/rxswift-81314827) <br>
[ashfurrow blog](https://ashfurrow.com/blog/) <br>
[Realm RxSwift 이선협](https://academy.realm.io/kr/posts/reactive-programming-with-rxswift/) <br>
[Realm RxSwift 시작하기 최완복님](https://academy.realm.io/kr/posts/letswift-rxswift/)<br>
[RxSwift로 시작하는 함수형 Reactive 프로그래밍 개론](https://academy.realm.io/kr/posts/slug-max-alexander-functional-reactive-rxswift/) <br>
[RxSwift 예제로 감잡기 : RxSwift 시작을 위한 간단한 예제들 - iOS Tech Talk](https://academy.realm.io/kr/posts/how-to-use-rxswift-with-simple-examples-ios-techtalk/) <br>
[Reactive MVVM(Model-View-ViewModel) 모바일 응용프로그램 아키텍쳐](https://justhackem.wordpress.com/2015/03/19/rmvvm-architecture/)<br>

[RxSwift 기본 익히기 (1) — 10 분짜리](https://medium.com/@trilliwon/rxswift-%EA%B8%B0%EB%B3%B8-%EC%9D%B5%ED%9E%88%EA%B8%B0-1-d4d77ce63ca8) <br>
[RxSwift 기본 익히기 (2) — 10 분짜리](https://medium.com/@trilliwon/rxswift-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-2-9%EB%B6%84-59-%EC%B4%88-f42f28407e75) <br>

[예제로 시작하는 RxSwift #1 - 기초](https://pilgwon.github.io/blog/2017/09/26/RxSwift-By-Examples-1-The-Basics.html)<br>
[예제로 시작하는 RxSwift #2 – 옵저버블(Observable)과 바인드(Bind)](https://pilgwon.github.io/blog/2017/10/09/RxSwift-By-Examples-2-Observable-And-The-Bind.html) <br>
[예제로 시작하는 RxSwift #3 – 네트워킹.](https://pilgwon.github.io/blog/2017/10/10/RxSwift-By-Examples-3-Networking.html)<br>
[예제로 시작하는 RxSwift #4 – 멀티스레딩.](http://www.thedroidsonroids.com/blog/ios/rxswift-examples-4-multithreading/) <br>




