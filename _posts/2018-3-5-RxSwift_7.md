---
layout:     post
title:      "RxSwift. 기초 정리하기 (7)"
subtitle:   "Time based Operators, Buffering operators, Windows of buffed observables, Time-shifting operators, Timer operators, Timeout"
date:       2018-03-05 17:13:00
author:     "MinJun"
header-img: "img/tags/Swift-bg.jpg"
comments: true 
tags: [RxSwift]
---


Raywenderlich-Ebook의 RxSwift를 읽고 정리한 내용입니다.

---

## RxSwift 정리 (7) 

- Time based Operators 
- Buffering operators
	- Replaying past elements
	- Unlimited replay
	- Controlled buffering
- Windows of buffed observables 
- Time-shifting operators
	- Delayed subscriptions
	- Delayed elements
- Timer operators
	- Intervals 
	- One-shot or repeating timers
	- Timeout 
- Circumscribe side effects(부수작용 억제하기-참고자료)
- Reference 

---

## Time Based Operators  

Reactive programming의 핵심 아이디어는 시간이 지남에 따라 비동기 데이터 흐름을 모델링 하는 것입니다. RxSwift는 시간과 시퀀스가 반응하고, 시간이 지남에 따라 변형되는 방식을 처리할수 있는 다양한 연산자를 제공합니다.

sequence의 시간을 관리하는 전략을 쉽습니다. time-based operators를 연습하려면 데이터의 흐름을 시각적으로 보여주는 animation을 이용하면 좋습니다. 

---

### Buffering operators 

- Buffering 연산자들은 과거의 요소들을 새로운 구독자에게 다시 재생하거나, 잠시 버퍼를 두고 줄수 잇씁니다. 언제, 어떻게 과거와 미래에 새로운 요소들을 전달하는 방법을 컨트롤하는지 배워봅니다. 

---

#### - Replaying past elements 

seqeunce가 아이템들을 방출할때 과거의 아이템을 구독자가 받는지 확신해야할 필요가 있을때가 있다. 그것은 `replay(_:)`, `replayAll()` operators의 목적입니다. 

또한 방출된 총 요소 수를 제한하고 새로운 구독자에게 `played back` 요소 수를 제어합니다. Observable<T>.create함수와 dispatch magic을 사용하여 방출을 관찰할수 있게 만듭니다(?)

DispatchSource.timer는 Playground에 정의된 extension 입니다. 그것은 반복 타이머의 생성을 단순화시킵니다. 요소를 방출하는 코드를 추가하세요.

`.replay`는 Source Observable로 부터 방출된 마지막 replayedElements를 기록하는 새로운 sequence를 생성합니다. 


```swift
class TimelineView<E>: TimelineViewBase, ObserverType where E: CustomStringConvertible {
    static func make() -> TimelineView<E> {
        return TimelineView(width: 400, height: 100)
    }
    public func on(_ event: Event<E>) {
        switch event {
        case .next(let value):
            add(.Next(String(describing: value)))
        case .completed:
            add(.Completed())
        case .error(_):
            add(.Error())
        }
    }
}

let elementsPerSecond = 1
let maxElements = 5
let replayedElements = 1
let replayDelay: TimeInterval = 3
let sourceObservable = Observable<Int>
    .interval(RxTimeInterval(1.0 / Double(elementsPerSecond)), scheduler: MainScheduler.instance)
    .replay(replayedElements)
let sourceTimeline = TimelineView<Int>.make()
let replayedTimeline = TimelineView<Int>.make()

let stack = UIStackView.makeVertical([
    UILabel.makeTitle("replay"),
    UILabel.make("Emit \(elementsPerSecond) per second:"),
    sourceTimeline,
    UILabel.make("Replay \(replayedElements) after \(replayDelay) sec:"),
    replayedTimeline])

_ = sourceObservable.subscribe(sourceTimeline)
DispatchQueue.main.asyncAfter(deadline: .now() + replayDelay) {
    _ = sourceObservable.subscribe(replayedTimeline)
}

_ = sourceObservable.connect()

let hostView = setupHostView()
hostView.addSubview(stack)
hostView
```

새로운 Observer가 구독할때마다, 버퍼링 된 요소(있는경우)를 즉시 수신하고 일반 구독과 같이 새로운 요소를 계속 수신합니다.

replay(:)의 실제 효과를 시각화 하기 위해, 한쌍의 TimeLineView를 생성합니다. 

TimeLineView 클레스는 Playground 아래쪽 Source 그룹의 TimeLineViewBase 클레스에 정의 되어 있습니다. 이 클래스는 observable의 이벤트 방출을 실시간으로 시각화 해줍니다.

`replay(_:)`가 connectable observable을 생성하기 대문에 아이템을 받기 시작하려면 기본 소스에 연결해야 합니다. 이 작업을 하지 않으면 구독자는 아무 값도받지 못합니다.  `connect()` 합니다.



> note `ConnectableObservable`은 Observable계열의 특별한 클래스 입니다. 이들은 `connect()` 메소드를 통해 불리기 전까지는 구독자 수와 관계 없이, 아무값도 방출하지 않습니다. 일부 연산자는 Observable<E>가 아닌 ConnectableObservable<E>를 반한합니다. 
> 
> 이 연산자는 다음과 같습니다. `replay(_:), replayAll(), multicast(_:), publish()`
> 
> 이들은 observable의 수에 관계없이 관찰 대상에 대한 단일 구독을 공유할수 있습니다.  <br>


<center><img src="/img/posts/Time-based.png" width="500" height="300"></center> <br> 

사용한 설정에서는 replayedElements는 1입니다. replay(_:) 연산자가 source observable에서 마지막으로 방출하는 값만을 버퍼로 두기 때문입니다

타임라인을 보면, 두번째 구독자가 3, 4 요소들을 동시에 받은 것을 볼수 있습니다. 구독하는 시간에 따라, 마지막 버퍼값인 3과, 두번째 구독을 함으로써 받은 4를 동시에 받은 것입니다. (사실 정확히 같은 순간은 아닙니다.)
`replayDelay`와 `replayedElements` 값을 변경해가면서 플레이해보자.

---

#### - Unlimited replay 

두번째로 사용할수 있는 재생 연산자는 replayAll() 입니다. 이 옵션은 주의해서 사용해야 합니다. 버퍼링된 요소의 총 수를 합리적으로 유지해야 하는 경우에만 사용하세요. 

예를들어 HTTP reqeusts의 context일때 replayAll()을 사용하세요. 쿼리에서 반환하는 데이터를 유지하는경우 메모리에 미치는 영향을 알수 있습니다. 

반면에, replayAll()을 사용하여 종료하지 않고 많은 양의 데이터를 생성할수 있는 seqeuence에서 사용하면 메모리가 부하가 생기게됩니다. 

위의 replay의 예제 코드중 `.replay(replayedElements)` 를 `reaplyAll()`로 부꾸어 보자

두번째 구독 즉시 모든 버퍼 요소들이 나타나는것을 확인 할수 있다.

---

#### - Controlled buffering 

`buffer(timeSpan:cout:scheduler:)` 연산자에 대해 먼저 알아봅시다. 

```swift
let bufferTimeSpan:RxTimeInterval = 4
let bufferMaxCount = 2
 
let sourceObservable = PublishSubject<String>()

let sourceTimeline = TimelineView<String>.make()
let bufferedTimeline = TimelineView<Int>.make()
 
let stack = UIStackView.makeVertical([
     UILabel.makeTitle("buffer"),
     UILabel.make("Emitted elements:"),
     sourceTimeline,
     UILabel.make("Buffered elements (at most \(bufferMaxCount) every \(bufferTimeSpan) seconds:"),
     bufferedTimeline])
 

_ = sourceObservable.subscribe(sourceTimeline)
 

sourceObservable
     .buffer(timeSpan: bufferTimeSpan, count: bufferMaxCount, scheduler: MainScheduler.instance)
     .map { $0.count }
     .subscribe(bufferedTimeline)
 

let hostView = setupHostView()
hostView.addSubview(stack)
hostView
 

DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
     sourceObservable.onNext("🐱")
     sourceObservable.onNext("🐱")
     sourceObservable.onNext("🐱")
}
```

위의 `replay`예제와 비슷합니다. 위의 코드는 `buffer`연산자를 구현하기 위한 행동들을 정의 합니다. 짧은 이모지를 입력하기 위해 `PublishSubject`를 사용합니다. 

버퍼된 타입은 각각 버퍼어레이에 있는 요소들의 개수를 보여줄것입니다. 

Source Observable의 Array에 있는 요소들을 받기를 원합니다. 각각의 array들은 bufferMaxCount 만큼의 요소를 가질수 있습니다. 이 많은 요소들이 bufferTimeSpan이 만료되기 전에 받아 졌다면, 연산자는 버퍼 요소들을 방출하고 타이머를 초기화 합니다. 마지막 그룹 방출 이후 bufferTimespan의 지연에서 `buffer`는 하나의 array를 방출할것 입니다. 만약 지연시간동안 받은 요소가 없다면 array는 빈값이 됩니다. 

Source Observable에 아무런 활동이 없어도, 버퍼 타임라인에 빈 버퍼가 있다는것을 확신 할수 있습니다. `buffer(_:scheduler:)` 연산자는 source observable에서 받을 것이 없으면 일정 간격으로 비어있는 Array를 방출합니다. 0은 source observable에서 0개의 요소가 방출되었음을 의미합니다.

이제 source observable에 데이터를 공급할수 있습니다. 버퍼링된 observable에 어떤 영향이 나타나는지 확인해봅니다. 먼저 5초동안 3개의 요소를 집어 넣어 봅니다. <br>

<center><img src="/img/posts/Time-based-1.png" width="500" height="300"></center> <br> 

각 상자에는 방출된 각 배열의 요소 수가 표시됩니다. 

- 처음에는 버퍼링된 타임라인이 빈 배열을 표시합니다
- 그러면 관찰 할수 있는 소스의 세 요소를 푸시합니다
- 버퍼링된 타임 라인은 두요소의 배열을 직시 가져옵니다. 지정한 최대계수(bufferMacCount 상수로 인해서)
- 4초가 지나면 하나의 요소만 있는 배열이 방출됩니다. source에 푸시된 세 가지 요소중 마지막 

보다시피, 버퍼는 전체 용량에 도달하면 즉시 요소 배열을 방출한다음, 지정된 배열을 기다리거나 다시 채워서 새 배열을 방출합니다. 다른 버퍼링 시나리오를 사용하여 더 많은 재생을 할수 있습니다. 요소를 내보내는 DispatchQueue를 제거하고 다음을 추가합니다.  <br>

1/0.7 간격으로 sourceObservle에 🐱을 푸시합니다. <br>

```swift
let elementsPerSecond = 0.7
let timer = DispatchSource.timer(interval: 1.0 /
Double(elementsPerSecond), queue: .main) {

   sourceObservable.onNext("🐱")
}
```

---

### Windows of buffed observables 


buffering의 마지막은 `window(timeSpan:count:scheduler:)` 입니다. `buffer(timeSpan:count:scheduler:)`과 비슷하게 작동하지만 유일한 차이점은 Array를 방출하는 대신 buffering된 Observable을 방출한다는 것 입니다. 

`window`의 sequence는 여러 Observable을 방출하므로, 개별적으로 시각화 하는게 좋습니다.

```swift
let elementsPerSecond = 3
let windowTimeSpan: RxTimeInterval = 4
let windowMaxCount = 10
let sourceObservable = PublishSubject<String>()

let sourceTimeline = TimelineView<String>.make()
let stack = UIStackView.makeVertical([
    UILabel.makeTitle("window"),
    UILabel.make("Emitted elements (\(elementsPerSecond) per sec.):"),
    sourceTimeline,
    UILabel.make("Windowed observables (at most \(windowMaxCount) every \(windowTimeSpan) sec):")])

let timer = DispatchSource.timer(interval: 1.0 /
    Double(elementsPerSecond), queue: .main) { sourceObservable.onNext("😡") }
_ = sourceObservable.subscribe(sourceTimeline)

_ = sourceObservable
    .window(timeSpan: windowTimeSpan, count: windowMaxCount, scheduler:
        MainScheduler.instance)
    .flatMap { windowedObservable -> Observable<(TimelineView<Int>, String?)> in
        let timeline = TimelineView<Int>.make()
        stack.insert(timeline, at: 4)
        stack.keep(atMost: 8)
        return windowedObservable
            .map { value in (timeline, value) }
            .concat(Observable.just((timeline, nil)))
}
    .subscribe(onNext: { tuple in
        let (timeline, value) = tuple
        if let value = value {
            timeline.add(.Next(value))
        } else {
            timeline.add(.Completed(true))
        }
    })
let hostView = setupHostView()
hostView.addSubview(stack)
hostView
```

String을 PublishSubject로 푸시하여 출력된 observable항목에서 시간별로 추력을 그룹화 하려고 합니다. 요소들을 source observable에 푸시하기 위한 타이머를 추가합니다. 

source timeline을 채웁니다. 각각 방출된 observable이 분리되어 볼수 있게합니다. 매번 `window(timeSpan:count:scheduler:)`가 새로운 observable을 방출할 때마다 새로운 타임라인을 삽입합니다. 이전 observable들은 아래로 내려가야 합니다. window observable은 어떻게 방출될 observable을 관리할수 있습니까? 

내부의 observable들을 `timeline`와 `value`를 조합한 튜플로 매핑합니다. 이 목적은 두 값을 표시할수 있는 곳으로 같이 옮기려는것 입니다. 

내부의 observable이 완료되면 `concat(_:)`으로 하나의 튜플을 연결 합니다. 이를 통해 타임 라인이 완료되었음을 표시할수 있게 됩니다.

`flatMap(_:)`으로 결과값(observable의 observable)을 하나의 tuple sequence로 변환 할수 있습니다. 

여기서 tuple속 value는 `String?`타입 입니다. 값이 `nil`이면, sequence가 종료되었음을 의미합니다. <br>

<center><img src="/img/posts/Time-based-2.png" width="500" height="300"></center> <br> 

맨 아래에서 두번째 타임 라인부터 살펴보면 모든 타임라인은 `가장 최근값` 입니다. windowed observable당 최대 5개 요소를 4초마다 `window`되도록 했습니다. 이 것은 새로운 observable이 적어도 4초마다 생성되고 5개의 요소를 모은 순간에 방출됩니다. 

---

### Time-shifting operators 

RxSwift는 과거의 실수를 수정하는데 도움이 되지 않지만 잠시동안 시간을 고정시켜 자기 복제가 가능할때까지 기다릴수 있습니다. 다음 두개의 시간관련 연산자를 살펴 보겠습니다. 


---

#### - Delayed subscriptions 

`delaySubscription(_:scheduler:)`에 대해서 알아봅시다. 지금까지 타임라인 애니메이션 만드는것을 많이 해봤으니까, 이번에는 간단히 `delaySubscription`에 해당하는 부분만 설명하겠습니다. 

```swift
_ = sourceObservable
  .delaySubscription(RxTimeInterval(delayInSeconds), scheduler:
MainScheduler.instance)
  .subscribe(delayedTimeline)
```

<center><img src="/img/posts/Time-based-3.png" width="500" height="300"></center> <br> 

이름에서 유추할수 있듯이, 구독을 시작후 요소를 받기 시작하는 시점을 지연하는 역활을 합니다. `delayInSeconds`에 정의된 것에 따라 지연 이후 보여질 요소들을 선택하기 시작합니다. 

> Note: Rx에서 observable에 대해 `cold` 또는 `hot`이라고 명명합니다. `cold` observable들은 요소들을 구독할때 방출을 시작합니다. `hot` observable들은 어떤 시점에서부터 영구적으로 작동합니다(Notifcation 같은) 구독을 지연 시켰을때, `cold`라면 지연에 따른 차이가 없지만. `hot` observable이라면 일정 요소를 건너뛰게 됩니다. 
> 
> 정리하면 `cold`observable은 요소들을 구독할때만 이벤트를 방출하지만, `hot` observable은 구독과 관계없이 이벤트를 방출한다는 점을 기억하세요

---

#### - Delayed elements 

RxSwift에서 또 다른 종류의 delay는 전체 sequence를 뒤로 미루는 작용을 합니다. 구독을 지연시키는 대신 source observable을 즉시 구독 합니다. 다만 요소의 방출을 설정한 시간만큼 미룬다는 것입니다. 

상단의 `delaySubscription(_:scheduler:)` 대신 아래의 코드를 추가합니다.

```swift
 _ = sourceObservable
     .delay(RxTimeInterval(delayInSeconds), scheduler: MainScheduler.instance)
     .subscribe(delayedTimeline)
```

<center><img src="/img/posts/Time-based-4.png" width="500" height="300"></center> <br> 

이전의 예에서 구독은 지연하면(기본설정으로) source observable항목의 처음 두요소가 누락 되었습니다. delay(_:scheduler:) operator를 사용하면 sequence 를 time-shift 하고도 아무것도 놓치지 않습니다. 

단순히 지연된 항목을 `볼수` 있습니다. 

---

### Timer operators

어떤 application dlems `timer`를 필요로 합니다. iOS와 macOS에는 이에 대한 다양한 솔루션들이 있습니다. 일반적으로 `NSTimer`가 해당 작업을 수행 했지만, 혼란스러운 소유권 모델을 가지고 있어 적절한 사용이 어려웠습니다. 

좀 더 최근에는 `dispatch`프레임워크가 `dispatch source`를 통해 타이머를 제공했습니다. 확실히 `NSTimer`보다 나은 솔루션 이지만, API는 여전히 랩핑 없이는 복잡합니다. 

이에 RxSwift는 간단하고 효과적인 솔루션을 제공합니다. 

---

#### - Intervals 

`DispatchSource`를 이용해서 일정간격의 타이머를 만들어봅니다. 이것을 `Observable.interval(_:scheduler:)`인스턴스로 전환될수도 있습니다. 정의된 스케줄러에서 선택된 간격으로 일정하게 전송된 `Int`값의 무한한 observable을 생성합니다(사실상 카운터 입니다.)

`replay`예제에서 `DispatchSource.timer(_:queue:)`을 포함하는 모든 부분을 아래의 코드로 대체합니다.

```swift
let sourceObservable = Observable<Int>
  .interval(RxTimeInterval(1.0 / Double(elementsPerSecond)), scheduler:
MainScheduler.instance)
  .replay(replayedElements)
```

<center><img src="/img/posts/Time-based-5.png" width="500" height="300"></center> <br> 

RxSwift 에서 interval timer들을 생성, 취소 하는것은 아주 쉽습니다. 
`Observable.interval(_:scheduler:)`은 observable을 생성하므로 구독을 손쉽게 `dispose()`로 취소할수 있습니다. 구독이 취소 된다는것은 타이머를 멈춘다는것을 의미합니다. 

observable에 대한 구독이 시작된 이후 정의된 간격동안 첫번째 값을 방출 시킬 수 있는 아주 명확한 방법입니다. 또한 타이머는 이 시점 이전에는 절대 시작하지 않습니다. 구독은 시작을 위한 방아쇠 역할을 하게 되는 것입니다.

타임라인에서 확인할 수 있듯이, Observable.interval(_ :scheduler:)를 통해 방출된 값은 0부터 시작한다. 다른 값이 필요하다면, map(_:)을 이용할 수 있습니다.

현업에서는 보통, 타이머를 통해 값을 방출하진 않습니다. 다만 아주 편리하게 index를 생성할 수 있는 방법이 됩니다.<참고글>

---

#### One-shot or repeating timers 

좀더 강력한 타이머를 원한다면 `Observable.timer(:period:scheduler:)` 연산자를 사용할수 있습니다. 이 연산자는 앞서 설명한 `Observable.interval(_:scheduler:)`와 유사하지만 몇가지 차이점이 있습니다. 

- 구독과 첫번째 값 방출 사이에서 `due date(마감일)`을 설정할수 있습니다.
- 반복기간은 `optional` 입니다. 만약 반복기간을 설정하지 않으면 타이머 observable은 한번만 방출된뒤 완료됩니다. 

`delay` 예제로 가서 `delay(_:scheduler:)` 연산자를 사용한 부분을 아래의 코드로 바구어 봅니다

```swift
_ = Observable<Int>
  .timer(3, scheduler: MainScheduler.instance)
  .flatMap { _ in
    sourceObservable.delay(RxTimeInterval(delayInSeconds), scheduler:
MainScheduler.instance)
  }
  .subscribe(delayedTimeline)
```

다른 타이머를 트리거하는 타이머? 이렇게 하면 어떤 이점이 있을까

- 가독성이 좋다.(좀 더 Rx 스럽다) 
- 구독이 disposable을 리턴하기 때문에, 첫번째, 두번째 타이머가 하나의 observable과 함께 트리거 되기 전, 언제든지 취소할수 있다.
- `flatMap(_:)` 연산자를 사용하므로써, `Dispatch`의 비동기 클로저를 사용하지 않고도 타이머 sequence들을 만들 수 있다.

---

#### - Timeout 

특별한 시간 제한을 사용하여 `time-based operators`를 검색할수 있습니다. 주된 목적은 실ㅈ 타이머와 시간 초과(오류)조건을 의미론적으로 구별 하는것입니다. 따라서 시간 초과가 발생하면 `RxError.TimeoutError` 오류 이벤트를 발생합니다. 오류를 찾지 못하면 sequence를 종료합니다.

```swift
let button = UIButton(type: .system)
 button.setTitle("Press me now!", for: .normal)
 button.sizeToFit()
 

let tapsTimeline = TimelineView<String>.make()
 
let stack = UIStackView.makeVertical([
     button,
     UILabel.make("Taps on button above"),
     tapsTimeline])
 

let _ = button
     .rx.tap
     .map { _ in "●" }
     .timeout(5, scheduler: MainScheduler.instance)
     .subscribe(tapsTimeline)
 

let hostView = setupHostView()
hostView.addSubview(stack)
hostView
``` 

만약 버튼이 5초 이내로 눌렸다면 뭔가를 프린팅하고 5초 이내 다시 눌려지지 않으면 sequence를 완전히 종료합니다. 버튼이 눌리지 않으면 에러 메세지를 프린트 합니다. 

`timeout(_:scheduler:)`의 다른 버전은 observable을 취하고 타임아웃이 시작되었을 때, 에러 대신 취한 Observable을 방출합니다. 위의 `timeout(_:scheduler:)`부분을 아래 코드로 변경해봅니다

```swift
.timeout(5, other: Observable.just("X"), scheduler: MainScheduler.instance)
```

위의 코드에선 빨간색 에러 이벤트를 방출 했지만, 이번에는 초록색의 일반적인 완료 이벤트가 "X"요소와 함께 방출됩니다. 

---

## 부수작용 억제하기(참고 자료)

- window(_:scheduler) 연산자에 대한 예제에서, 우리는 타임라인을 flatMap(:_) 연산자의 클로저 내부에 생성했다.
 
- 이 작업은 코드를 간략하게 만들기 위함이었지만, 반응형 프로그래밍의 가이드라인 중 하나는 "단일체monad에서 벗어나지 말 것" 이다. 다시 말하면 부수작용을 최대한 내지 말라는 것이다.

- 여기서의 부작용은 변형만 발생해야하는 시점에 새 타임라인도 생성되는 것이다.

- 따라서 기존에 작성한 코드 대신에 다른 방법을 찾는 것이 이번 과제다. 물론 다양한 방법이 있을 수 있지만, 가장 효과적인 방법은, 작업을 여러개의 observable로 나누고, 추후에 이들을 합치는 방법일 것이다.
	- windowed observable들을 하나씩 나누는 방법은 타임라인 뷰를 준비하고 (do(onNext:) 연산자를 통해 부작용이 발생할 수 있음을 인지할 것),
생성된 타임라인 뷰와 source sequence의 요소를 사용하여, (힌트. zip과 flatMap을 조합해볼 것)
	- window가 새로운 sequence를 내보낼 때마다 상황에 따른 값 (타임라인 뷰와 sequence)를 생성한다

```swift
let windowedObservable = sourceObservable
    .window(timeSpan: windowTimeSpan, count: windowMaxCount, scheduler: MainScheduler.instance)

let timelineObservable = windowedObservable
    .do(onNext: { _ in
        let timeline = TimelineView<Int>.make()
        stack.insert(timeline, at: 4)
        stack.keep(atMost: 8)
    })
    .map { _ in
        stack.arrangedSubviews[4] as! TimelineView<Int>
}

_ = Observable
    .zip(windowedObservable, timelineObservable) { obs, timeline in
        (obs, timeline)
    }
    .flatMap { tuple -> Observable<(TimelineView<Int>, String?)> in
        let obs = tuple.0
        let timeline = tuple.1
        return obs
            .map { value in (timeline, value) }
            .concat(Observable.just((timeline, nil)))
    }
```

- 기존 window가 부수작용을 내는지 확인하기 어렵기 때문에 do(onNext:)를 통해 스택뷰에 영향을 주는 놈들을 표시한다.
	- 사실 기존 코드대로 사용해도 크게 문제가 생기는 것은 아니다. 다만 windowed observable에서 stack의 .insert와 .keep은 .do에 있는게 맞고 .map에는 사용하지 않는것이 맞다고 판단되는 것.
- 모나드란?
	- 위키를 확인하세요.
	- .map, .flatten, .flatMap을 최소조건으로 해서 적용 가능한 모든 Generic들
	- 예) array, optional 등

---

## Reference 


* 공식 

[http://reactivex.io](http://reactivex.io/documentation/ko/observable.html) <br> 
[Introduce to Rx](http://www.introtorx.com/Content/v1.0.10621.0/00_Foreword.html) <br>
[RxJS Marbles](http://rxmarbles.com/) <br>
[RxSwift github](https://github.com/ReactiveX/RxSwift) <br>
[http://community.rxswift.org/](http://community.rxswift.org/) <br>

* 개인 참조 

[fimuxd님 github](https://github.com/fimuxd/RxSwift/blob/master/Lectures/11_Time%20Based%20Operators/Time%20Based%20Operators.md)







