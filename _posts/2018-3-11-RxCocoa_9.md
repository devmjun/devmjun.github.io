---
layout:     post
title:      "RxCocoa. 기초 정리하기 (9)"
subtitle:   "activity while searching, ExtendUIKit, Extension rx, Extension delegate.."
date:       2018-03-11 14:11:00
author:     "MinJun"
header-img: "img/tags/Swift-bg.jpg"
comments: true 
tags: [RxCocoa]
---

Raywenderlich-Ebook의 RxSwift를 읽고 정리한 내용입니다.
아래 내용의 저작권과 이미지는 모두 [https:/www.raywenderlich.com/](https://www.raywenderlich.com/) 에 있습니다. 더 자세한 내용은 [여기서 책을 구입해주세요!](https://store.raywenderlich.com/products/rxswift)

---

## RxCocoa 정리 (9) 

- Intermediate RxCocoa
- Getting started
- Showing an activity while searching 
- Extending CCLocationManager to get the current position 
	- Creating the extension
	- Using the button to get the current position 
	- Update the weather with the current data 
- How to extend a UIKit view 
	- ExtendUIKit views using MKMapView 
	- Display overlays in the map
	- Use the created binding 
	- Observing for map scroll events 
	- React to regionDidChangeAnimated event 
- Conclusion about RxCocoa 
- 추가로 Signal!
- Challenge 1: Add a binding property to focus the map on a given point
- Challenge 2: Use the MKMapView to navigate a location and display the surrounding weather conditions
- Reference 

---

## Intermediate RxCocoa 

고급 RxCocoa와, UIKit 구성 요소에 대한 custom wrappers 생성 방법에 대해서 배우게 됩니다. 

여기서는 RxSwift/Rxcocoa 프로젝트를 구성하는 최선의 아키텍쳐를 다루지 않습니다.(MVVM은 나중에 배우게 됩니다.)

---

## Getting started 

OpenWeatherMap API를 사용한 이전의 프로젝트를 사용합니다.

[http://openweathermap.org](http://openweathermap.org) <br>
[https://home.openweathermap.org/api_keys ](https://home.openweathermap.org/api_keys)<br>

API를 사용하기 위해서 OpenWeather에 가입후, API KEY를 발급받고 사용 해야합니다. 

```swift
private let apiKey = "[YOUR KEY]"
```

---

## Showing an activity while searching 

Application은 현재 특정 도시의 가상 정보를 표시하지만 사용자가 검색 버튼을 누르면 아무런 피드백도 제공하지 않습니다. 앱이 네트워크 요청을 수행하는 동안 Activity indicator를 표시하는것이 좋습니다. 이 작업이 끝나면 앱 로직은 다음과 같습니다. 

<center><img src="/img/posts/Intermediate_RxCocoa.png" width="500" height="300"></center> <br> 

이를 위해서, 이벤트 스트림을 작은 이벤트 스트림으로 분해하여 사용자가 버튼을 누를 때 알림을 받고 서버에서 데이터가 도착했는지 확인 해야합니다.

```swift
// searchInput 해주는 Text
let searchInput =
            searchCityName.rx.controlEvent(.editingDidEndOnExit).asObservable()
	.map { self.searchCityName.text }
	.filter { ($0 ?? "").characters.count > 0 }
        
// Search 가 처리 되는곳.
let search = searchInput.flatMap { text in
	return ApiController.shared.currentWeather(city: text ?? "Error")
		.catchErrorJustReturn(ApiController.Weather.dummy)
            }
	.asDriver(onErrorJustReturn: ApiController.Weather.dummy)
        
// from -> Array -> Observable sequence 로 변경
let running = Observable.from([
		searchInput.map { _ in true },
		search.map { _ in false }.asObservable()
		])
	.merge()
	.startWith(true)
	.asDriver(onErrorJustReturn: false)
```

<center><img src="/img/posts/Intermediate_RxCocoa-1.png" width="500" height="300"></center> <br> 

`.asObservable()`호출은 배열중 하나의 요소를 찾는것을 도와주는데 Swift의 타입 추론을 위해 필요합니다. 이후 두개의 observable을 merge할수 있습니다. 

`.startWith(true)`는 앱이 시작할때 모든 label을 수동적으로 숨길 필요가 없게 해주는 아주 편리한 호출입니다. 

이 시점에서 바인딩은 매우 간단하게 작성할 수 있습니다. 라벨을 바인딩하기 전이나 후에 레이블을 배치할수 있습니다.

첫번째 값은 수동으로 주입해서 값을 건너뛰어야합니다. 그렇지 않으면 Application이 시작됬을때 바로 indicator가 실행되기 때문입니다. 그 이후 다음을 추가하여 상태에 따라서 레이블을 숨기고 표시하십시오!

```swift
running
  .skip(1)
  .drive(activityIndicator.rx.isAnimating)
  .disposed(by: bag)
```

```swift
running
  .drive(tempLabel.rx.isHidden)
  .disposed(by: bag)
running
  .drive(iconLabel.rx.isHidden)
  .disposed(by: bag)
running
  .drive(humidityLabel.rx.isHidden)
  .disposed(by: bag)
running
  .drive(cityNameLabel.rx.isHidden)
  .disposed(by: bag)
```

Application이 실행되고, 어떤 것들이 보일 것 입니다. 모든 레이블은 숨김상태이고, Activity indicator은 실행되지 않아야합니다. <br>

| * | * | 
| :--: | :--: |
|![screen](/img/posts/Showing_an_activity.png) |![screen](/img/posts/Showing_an_activity-1.png) | <br>

---

## Extending CCLocationManager to get the current position 

CCLocationManager를 extension하여 현재 위치를 가져옵니다.

RxCocoa는 UI만을 위한것은 아닙니다. 기본 목적은 Apple의 공식 프레임워크들을 래핑하여 간단하고 강력한 방법으로 사용자화 하는데 있습니다. 

현재 날씨앱은 현재 위치를 알지 못합니다. 따라서 RxCocoa에서 제공하는 일부 구성요소를 수정하여 이 기능을 구현해봅니다. 

---

### Creating the extension 

첫번째로 `CoreLocatoin` 프레임워크를 통합하는 레퍼를 만드는 것입니다. `CLLocationManager + Rx.swift` 열어보면, 이것은 `extension`이 생성될 파일들 입니다. 이 파일들을 보면 모든 extension은 `rx`키워드가 포함되어 있습니다. `CLLocationManager`도 동일한 패턴을 따르는 것입니다. 

<center><img src="/img/posts/Intermediate_RxCocoa-2.png" width="500" height="300"></center> <br> 

Pod 프로젝트 내부의 `Reactive.swift`라는 파일을 찾습니다. 파일을 열면 `Reactive<Base>`라는 구조체, `ReactiveCompatible` 프로토콜 이자 `ReactiveCompatible`의 `extension` 입니다. 

`ReactiveCompatible` extension이 `rx` 네임 스페이스를 만들수 있는 변수를 가지고 있습니다.

```swift
/// Extend NSObject with `rx` proxy.
extension NSObject: ReactiveCompatible { }
```

이것은 `NSObject`로 부터 상속받은 모든 클래스가 `rx` 네임 스페이스를 얻는 방법입니다. 

사용자는 `CLLocationManager` 클레스에 대한 전용 rx확장을 생성하고 다른 클래스가 사용할수 있도록 노출시키는 것입니다.

`RxCocoa`폴더도 확인해보자. 여기서 `_RxDelegateProxy.h`, `_RxDelegateProxy.m`라 명명된 Objective-c 파일을 찾을수 있씁니다. 이들은 Swift의 `DelegateProxy.swift`, `DelegateProxyType.swift`와 같은 역활을 하는 녀석들입니다. 이들을 데이터 제공을 위한 주요 리소스로 delegate(데이터소스)를 사용하는 모든 프레임워크들과 RxSwift를 연결해주는 솔루션 구현한 녀석들입니다. 

`DelegateProxy`객체는 수신된 모든 데이터를 전용 observable로 표현할 가짜 deleaget객체를 만들어 냅니다.

<center><img src="/img/posts/Intermediate_RxCocoa-3.png" width="500" height="300"></center> <br> 

`CLLocationManager`는 `delegate`를 필요로 하고, 때문에 필요한 location manager delegate에서 전용 `observable`로 모든 데이터를 보내는데 필요한 proxy를 만들어야 합니다. 1:1 관계의 매핑이므로 단일 프로토콜 함수는 주어진 데이터를 반환하는 단일 observable에 해당될 것입니다.

아래의 코드를 `CLLocationManager+Rx.swift`에 추가합니다.

```swift
class RxCLLocationManagerDelegateProxy: DelegateProxy, CLLocationManagerDelegate, DelegateProxyType { 
}
```

`RxCLLocationManagerDelegateProxy`는 Observable이 생성되고 subscription이 생성된 이후에. CLLocationManager 인스턴스에 붙어있는(?) Proxy가 될것입니다. 

이 시점에서 proxy delegate를 위해서 `setter`, `getter`를 추가해줄 필요가 있습니다. 

첫번째로 class에 `setter`를 추가합니다.

```swift
// getter
    class func currentDelegateFor(_ object: AnyObject) -> AnyObject? {
        let locationManager: CLLocationManager = object as! CLLocationManager
        return locationManager.delegate
    }

    // setter
    class func setCurrentDelegate(_ delegate: AnyObject?, toObject object: AnyObject) {
        let locationManager: CLLocationManager = object as! CLLocationManager
        locationManager.delegate = delegate as? CLLocationManagerDelegate
    }
```

위의 두개 함수를 사용하여 `CLLocationManager`인스턴스에 연결된 observable 에서 데이터를 이동하는데 사용되는 프록시가 될 Delegate를 가져오고 설정할수 있습니다. 

이것은 RxCocoa 에서 Delegate Proxy 패턴을 사용하여 클래스를 확장하는 방법 입니다. 

이제 방금 만든 Proxy Delegate를 사용하여 위치변경을 관찰할수있는 Observable하는 observer를 만듭니다. 

```swift
// Observable 하는 observe를 만들기 위한 Delegate 설정
extension Reactive where Base: CLLocationManager {
    var delegate: DelegateProxy {
        return RxCLLocationManagerDelegateProxy.proxyForObject(base)
    }
}
```

이제 `Reactive` extension을 사용하면 `CLLocationManager` 인스턴스의 `rx`네임 스페이스에 있는 해당 확장 내에서 메소드가 노출됩니다. 이제 모든 `CLLocationManager`인스턴스에 대해 노출 확장자 rx를 사용할수 있지만, 불행히도 실제 데이터를 가져올 실제 observables이 없습니다. 

방금 만든 extension에 다음 코드를 추가하여 문제를 해결하세요!

```swift
var didUpdateLocations: Observable<[CLLocation]> {
  return
delegate.methodInvoked(#selector(CLLocationManagerDelegate.locationManage
r(_:didUpdateLocations:)))
    .map { parameters in
      return parameters[1] as! [CLLocation]
	} 
}
```

위의 함수를 사용하면 Proxy로 사용된 delegate가 `didUpdateLocation`의 모든 호출을 수신하여 데이터를 가져와 `CLLocation` 배열에 캐스팅합니다. 

`methodInvoked(_:)`는 RxCocoa에 있는 Objective-C 코드의 일부이며, 기본적으로 delegate를 위한 low-level observer 입니다. 

`methodInvoked(_:)`는 지정된 메소드가 호출될 때마다 `next` 이벤트를 보내는 observable을 반환합니다. 이러한 이벤트에 포함된 요소는 method가 호출된 parameter의 array입니다. 이 array를 `parameters[1]`로 접근하여 `CLLocation`의 array에 캐스팅 합니다.

이제 extension을 애플리케이션에 통합할 준비가 되었습니다.

---

### Using the button to get the current position 

먼저 UI작업을 하려면 VIewController.swift로 전환하세요. 그리고 `CoreLocation framwork`를 import 합니다.

<center><img src="/img/posts/Intermediate_RxCocoa-4.png" width="300" height="200"></center> <br> 


```swift
import CoreLocation

let locationManager = CLLocationManager()
```

> Note: viewDidLoad()내에서 `location manager instance`를 생성하면, object의 해제(release)가 발생하고, alert이 표시됩니다. 이는 `reqeustWhenInUserAuthorization()` 호출되면 즉시 제거 됩니다.
> 

이제 응용 프로그램에 사용자 위치에 엑세스 할수 있는 충분한 권한이 있는지 확인해야 합니다. 

iOS8 부터 OS는 Geolocation 데이터를 사용하기전에 사용자의 허가를 요청해야합니다.

따라서 사용자가 현재 위치 버튼을 누를때 가장 먼저 해야할일은, 현재 위치 데이터를 사용하고 데이터를 업데이트 할수 있는 권한을 주거나 확인하기위해 다음 코드를 추가합니다.

```swift
* in ViewDidLoad 

// 사용자의 위치 정보를 가져오기전에, 위치 버튼을 눌렀을때. 사용자의 위치 사용데이터에 대한 권한을 확인 해주는 작업.
        geoLocationButton.rx.tap
            .subscribe(onNext: { _ in
                self.locationManager.requestWhenInUseAuthorization()
                self.locationManager.startUpdatingLocation()
            })
            .disposed(by: bag)
        
        // 권한 확인후, 사용자의 데이터를 rx를 통해서 가져옵니다.
        locationManager.rx.didUpdateLocations
            .subscribe(onNext: { location in
                print(location)
                
            })
            .disposed(by: bag)
```

<center><img src="/img/posts/Intermediate_RxCocoa-5.png" width="500" height="600"></center> <br> 

> Note: 시뮬레이터에서 사용한다면 fake location이 콘솔창에 출력됩니다.

이 시점에서 사용자가 앱이 자신의 위치에 엑세스 할수 있는 권한을 부여했다고 가정하면 앱은 해당 위치 데이터를 사용하여 지역 날씨를 검색 할수 있습니다. `ApiController.swift`에는 사용자의 위도와 경도를 기반으로 서버에서 데이터를 검색하는 전용 함수가 있습니다. 

```swift
func currentWeather(lat: Float, lon: Float) -> Observable<Weather>
```

이 함수는 지리적 좌표에서 Weather instance를 반환합니다. 이를 사용하여 필요한 데이터를 서버에서 가져옵니다. 

`viewDidLoad` 에서 마지막 유효한 위치를 반환하는 observable을 생성 합니다. 

```swift
let currentLocation = locationManager.rx.didUpdateLocations
  .map { locations in
    return locations[0]
  }
  .filter { location in
    return location.horizontalAccuracy < kCLLocationAccuracyHundredMeters
  }
```

`didUpdateLocations`는 가져온 위치의 배열을 내보닙니다. 그러나 한개의 location 만 필요하기 때문에, map을 사용합니다. 

그런 다음 필터를 사용하여 완전히 다른 데이터로 작업하지 못하도록 하고 위치가 100미터 이내에 있는지 확인하십시오!

> `location.horizontalAccuracy`은 위치의 위도와 경도는 원의 중심을 식별하며 이 값을 해당 원의 반지름을 나타냅니다. 음수 값은 위도와 경도가 유효하지 않음을 나타냅니다. 
> 

---

### Update the weather with the current data 

사용자의 위치를 반환하는 observable을 가져야 하고, 위도와 경도를 기반으로 날씨를 얻을수 있는 메커니즘이 있어야합니다. RxSwift의 자연스러운 조합은 다음과 같습니다. 

<center><img src="/img/posts/Intermediate_RxCocoa-6.png" width="500" height="300"></center> <br> 

```swift
* geoLocationButton.rx.tap 코드를 다음같이 변경합니다.

let geoInput = geoLocationButton.rx.tap.asObservable()
  .do(onNext: {
    self.locationManager.requestWhenInUseAuthorization()
    self.locationManager.startUpdatingLocation()
  })
let geoLocation = geoInput.flatMap {
  return currentLocation.take(1)
}
```

이렇게하면 Location manger가 위치에 대한 정보를 업데이트하고 하나의 값만 제공합니다. 

새 값이 위치 관리자로부터 도착 할 때마다 프로그램이 업데이트되는것을 방지할수 있습니다. 다음으로 날씨 데이터를 검색하기 위해 새로운 Observable을 만듭니다. 

```swift
let geoSearch = geoLocation.flatMap { location in
  return ApiController.shared.currentWeather(lat:
location.coordinate.latitude, lon: location.coordinate.longitude)
    .catchErrorJustReturn(ApiController.Weather.dummy)
}
```

이렇게하면 geoSearch를 Weather 유형으로 Observable 할수 있습니다. 이는 도시 이름을 입력으로 사용하여 호출 한것과 같습니다.

같은 날씨 유형을 반환하고 동일한 작업을 수행하는 두개의 observable.. 이코드는 약간의 리펙토링이 필요합니다(초기에는 도시명으로 날씨정보를 가져왔지만 -> 지금은 위, 경도를 주고 날씨 정보를 가져와야 하기때문)

도시이름을 사용하는 함수와, observable을 merge()할수 있습니다. 이렇게 하면 새로운 기능에 대한 전체 Application을 리펙터링 하지 않고도 동일한 결과를 얻을수 있습니다. 

목표는 Weather의 Drive로 검색을 유지하고, Application의 현재 상태를 observable 가능한 상태로 running 하는것입니다. 


기존의 `search`를 삭제하고 다음과 같이 새코드를 `searchInput`아래에 추가합니다. 

```swift
let textSearch = searchInput.flatMap { text in
  return ApiController.shared.currentWeather(city: text ?? "Error")
    .catchErrorJustReturn(ApiController.Weather.dummy)
}
```

이제 `textSearch`와 `geoSearch`를 결합하여 새로운 검색 Observable을 만들수 있습니다. 

```swift
let search = Observable.from([
    geoSearch, textSearch
  ])
  .merge()
  .asDriver(onErrorJustReturn: ApiController.Weather.dummy)
```

이제 이것은 source(도시명 또는 사용자의 현재위치)와는 관계없이 UI에 `Weather`객체를 전달합니다. 마지막 단계는 피드백을 제공하고 검색할동안 `activity indicator`를 올바르게 표시한뒤, 요청이 완료되면 숨깁니다. 

```swift
let running = Observable.from([
    searchInput.map { _ in true },
    geoInput.map { _ in true },
    search.map { _ in false }.asObservable()
])
```

running observable로 가서, geoInput애 대한 조건을 추가한다. 이제 도시명 또는 현재위치를 통해 검색하는 결과는 정확히 똑같이 나타난다.

<center><img src="/img/posts/Intermediate_RxCocoa-7.png" width="500" height="300"></center> <br> 

지금까지 과정을 통해 앱의 기능을 확장시켰습니다. 다음 그림 처럼 단순한 단방향 스트림을 멀티소스로 바꾸는 `merge()` 연산자를 통해 입력값을(도시명+ 현재위치)를 추가했습니다. 

<center><img src="/img/posts/Intermediate_RxCocoa-8.png" width="500" height="300"></center> <br> 

running status 에 다음과 같은 변경사항도 있습니다. 

앱을 만들기 시작할때는 하나의 textSource(도시명 입력값)로 시작했지만, 지금은 두개의 데이터 소스를 가지고 있습니다. 

---

## How to extend a UIKit view 

이제 `RxCocoa`가 제공하는것 이상으로 UIKit구성 요소를 확장하는 방법을 알아보아야합니다.

이 Application은 현재 사용자의 위치의 날씨를 표시하지만 주위를 스크롤하거나 탐색하는 동안 지도에서 주변 날씨를 탐색하는것이 좋습니다. 

이는 `MKMapView`클레스에 새로운 extension을 작성하라는것처럼 들립니다....

---

### ExtendUIKit views using MKMapView 

`MKMapView`를 extension 하려면 `CLLocationManager`를 extension 하는데 사용한 패턴과 완전히 동일한 패턴으로 시작합니다. Proxy Delegate `RxMkMapViewDelegateProxy`를 만들고 `MKMapView`기본 클래스에 대해 `Reactive`를 확장합니다. 

`Extension`디렉토리에 있는 MKMapView + Rx.swift를 열고 확장 프로그램의 기반을 만듭니다. 

```swift
class RxMKMapViewDelegateProxy: DelegateProxy, MKMapViewDelegate, DelegateProxyType {
    // Getter
    class func currentDelegateFor(_ object: AnyObject) -> AnyObject? {
        let mapView: MKMapView = (object as? MKMapView)!
        return mapView.delegate
    }
    
    // Setter
    class func setCurrentDelegate(_ delegate: AnyObject?, toObject object:
        AnyObject) {
        let mapView: MKMapView = (object as? MKMapView)!
        mapView.delegate = delegate as? MKMapViewDelegate
    }
    
}

extension Reactive where Base: MKMapView {
    public var delegate: DelegateProxy {
        return RxMKMapViewDelegateProxy.proxyForObject(base)
    }    
}
```

Proxy를 만들었습니다. 이제 `MKMapView`를 확장하여 delegate methods observables을 처리할수 있습니다. 

`MKMapView`를 확장하기전에 현재 프로젝트의 map View가 정확하게 표시되는지 확인합니다. 버튼은 ViewController의 오른쪽 하단에 이미지 버튼이 있습니다.

<center><img src="/img/posts/Intermediate_RxCocoa-9.png" width="300" height="200"></center> <br> 

viewDidLoad()에 아래의 코드를 추가합니다. 버튼이 눌렷을때 mapView를 표시하거나 숨깁니다. 


```swift
// MapView 관련 코드
        // MapView를 터치했을때, MapView가 보이거나, 사라지게 함
        mapButton.rx.tap
            .subscribe(onNext: {
                self.mapView.isHidden = !self.mapView.isHidden
            })
            .disposed(by: bag)
```

빌드후, button을 터치하면 아래의 이미지를 확인할수 있습니다.

<center><img src="/img/posts/Intermediate_RxCocoa-10.png" width="300" height="200"></center> <br> 

---

### Display overlays in the map

이제 지도에서 데이터를 수신하고 표시할 준비가 되었지만 먼저 날씨 오버레이를 추가하려면 약간의 작업이 필요합니다. 

오버레이를 지도에 추가하려면 delegate method중 하나를 구현하세요.

```swift
func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) ->
MKOverlayRenderer
```

Rx를 반환하는 형식이 있는 delegate를 래핑하는것은 두가지 이유로 매우 어려운 작업입니다.

- 반환타입이 있는 delegate method는 observable을 위한 것을 의미하는게 아니라 행동(behavior)의 사용자화를 위한 메서드 입니다. 
- 자동적으로 기본값을 지정하는것은 일단 중요한 작업이 아닙니다. 

따라서 여기서 최상의 솔루션은 delegate의 기본구현에 이 호출을 전달하는 것입니다.

<center><img src="/img/posts/Intermediate_RxCocoa-11.png" width="500" height="300"></center> <br> 

기본적으로 두가지 장점을 모두 얻고 있습니다. 일반적인 UIKit 개발과 마찬가지로 반환 값을 사용하여 delegate method를 준수하는 실용성을 원하지만 함수를 위힘할때 observable을 사용할수도 있습니다. 

이번에는 두가지 방법이 있습니다. 

`MKMapViewDelegate`는 반환 유형이 필요한 delegate 함수가 있는 유일한 프로토콜이 아니므로 이미 도움이 되는 메소드가 있습니다. 

```swift
public static func installForwardDelegate(_ forwardDelegate: AnyObject,
retainDelegate: Bool, onProxyForObject object: AnyObject) -> Disposable
```

위의 매소드를 확인하고싶다면 `DelegateProxyType.swift` 에 가면 확인할수 있습니다. Rx Proxy에 wrapper가 되지않은 delegate 메서드를 전달 하려고 합니다. MKMapView를 위한 Reactive extension에 다음을 추가합니다.

```swift
public func setDelegate(_ delegate: MKMapViewDelegate) -> Disposable {
  return RxMKMapViewDelegateProxy.installForwardDelegate(
    delegate,
    retainDelegate: false,
    onProxyForObject: self.base
) 
}
```

위의 함수를 사용하면 호출을 전달하고 필요한 경우 반환값을 제공하는 delegate를 설치할수 있습니다. `viewDidLoad()` 끝에 다음을 추가하여 RxProxy에서 처리되지 않은 모든 호출을 받은 delegate로 ViewController를 설정합니다. 

```swift
mapView.rx.setDelegate(self)
	.disposed(by: bag)
```

위의 코드를 작성하면 프로토콜을 채택하지 않았다는 컴파일 에러가 발생합니다. 이것을 해결하기 위해서 아래 코드를 `ViewController.swift`에 추가합니다. 

```swift
extension ViewController: MKMapViewDelegate {
     func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -> MKOverlayRenderer {
         if let overlay = overlay as? ApiController.Weather.Overlay {
             let overlayView = ApiController.Weather.OverlayView(overlay: overlay, overlayIcon: overlay.icon)
             return overlayView
         }
         return MKOverlayRenderer()
     }
}
```

- `OvserlayView`는 지도 정보를 띄우기 위해 `MKMapView`인스턴스를 필요로 합니다
- 여기서의 목적ㅇ느 단순합니다. 날씨 아이콘을 추가적인 정보 없ㅇ; 지도 위에 띄우는 것입니다.
- 현재까지 작업으로 delegate의 리턴타입, 전달된 proxy생성, 화면 오버레이 셋팅을 완료했습니다. 이제 이러한 overlay들을 RxSwift로 함께 작업하는것만이 남았습니다.

`MKMapView + Rx.swift`로 돌아가서 다음 바인딩 observer를 Reactive extension에 추가하면 MKOverlay의 모든 인스턴스를 가져와서 현재 맵에 삽입합니다.

```swift
var overlays: UIBindingObserver<Base, [MKOverlay]> {
  return UIBindingObserver(UIElement: self.base) { mapView, overlays in
    mapView.removeOverlays(mapView.overlays)
    mapView.addOverlays(overlays)
  }
}
```

`UIBindingObserver`를 사용하면 bind, drive기능을 사용할수 있습니다. 

`overlays` binding observable 안에서 이전 Overlay들은 매번 `Subject`에 새 array가 보내질때마다 사라지고 재 생성될것입니다. 

이 앱의 목적을 고려해보면 이코드는 더이상의 최적화 작업은 필요 없습니다. 한번에 10개가 넘은 overlay가 있을것 같지 않으므로 모든 것을 제거하고 새것을 추가한느것은 적절합니다. 

더 많은것을 처리해야하는 경우 `diff algorithm`을 사용하여 성능을 향상시키고 `overhead`를 줄일수 있습니다.

---

### Use the created binding 

`ApiController.swift`를 열고 `Weather` struct를 확인합니다. 여기에는 `Overlay` 및 `OverlayView`라는 두가지 클래스가 있습니다.

`Overlay`는 `NSObject`의 서브클래스이며, `MKOverlay`프로토콜을 준수합니다. 이는 지도를 통해 실제 데이터를 렌더링 하기위해 `OverlayView`에 전달할 정보 객체입니다. 여기서 알아두어야하는것은 `Overlay`는 지도에 아이콘을 표시하는데 필요한 정보만 담고 있다는 것입니다. 

`OverlayView`는 오버레이 렌더링을 담답합니다. 이미지가져오기를 피하기위해 `imageFromText`는 텍스트를 이미지로 변환하므로, 아이콘을 맵에 오버레이로 표시할수 있습니다. `OverlayView`는 새로운 인스턴스를 만들기 위해 기본 오버레이 인스턴스와 아이콘 텍스트만 필요로 합니다. 

`Weather`struct에 아래와 같은 함수를 발견할수 있습니다. 이 함수는 Overlay로 변환해주는 편리한 합니다.

```swift
func overlay() -> Overlay { ... }
```

ViewController.swift로 돌아가서 다음 코드를 viewDidLoad()에 추가합니다.

```swift
search.map { [$0.overlay()] }
	.drive(mapView.rx.overlays)
	.disposed(by: bag)
```

이는 새로 도착한 데이터를 앞서 만든 오버레이 `subject`와 바인딩 합니다. 그리고 `Weather` struct를 올바른 `overlay`에 매핑합니다. 

앱을 실행 시켜서 도시를 검색해봅니다. 그리고 지도를 열어 해당 도시로 이동합니다. 다음과 같은 화면을 확인할수 있습니다. 

<center><img src="/img/posts/Intermediate_RxCocoa-12.png" width="400" height="200"></center> <br> 

결과는 좋아 보이며 검색한 도시 위치에 아이콘이 표시됩니다.

---

### Observing for map scroll events 

`binding property`를 사용하여 `MKMapView`를 extension 한후에 Delegate에 대한 보다 일반적인 Notification 메커니즘을 구현하는 방법을 알아 봅니다. 

`CLLocationManager`에서 했던것과 다른점이 없으므로 동일한 패턴을 따라갈수 있습니다. 

이 경우 목표는 MapView에서 사용자 drag 이벤트 및 기타 탐색 이벤트를 수신하는것입니다. 사용자가 탐색을 멈추면 지도 중간의 기상 조건을 업데이트하고 표시합니다. 

이러한 변화를 추적할수 있도록 MKMapViewDelegate는 다음과 같은 메소드를 제공합니다.

```swift
func mapView(_ mapView: MKMapView, regionDidChangeAnimated animated:
Bool)
```

이 delegate 메서드를 구현하면 새 영역으로 드레그할때 마다 delegate method가 호출됩니다. 이것은 MKMapView+Rxswift에서 reactive extension을 추가로 만들 기회입니다.`반환값이 없는 delegate method`를 구현하는 메커니즘을 사용합니다.

```swift
*MKMapView+Rx.swift를 열고 아래의 코드를 extension 내에 추가합니다. 
public var regionDidChangeAnimated: ControEvent<Bool> {
 	let source = delegate
 		.methoudInvoked(#selector(MKMapViewDelegate.mapView(_:regionDidChangedAnimated:)))
 		.map { parameters in
 			return (parameters[1] as? Bool) ?? false
 		}
 	return ControlEvent(events: source)
 }
```

안전을 위해, 캐스팅이 실패했을 땐 해당 메소드가 false 를 내뱉도록 했습니다. 

---

### React to regionDidChangeAnimated event 

Drag에 대한 정보가 제공되며 RxSwift를 사용하는 관측 메커니즘이 마련되어 있습니다. 유일한 누락 된 부분은 이전에 생성된 ControlEvent를 실제로 사용하는것입니다. 

`ViewController.swift`로 전환하여 다음과 같이 변경합니다. 

- 이전에 생성된 observable을 사용할 `mapInput`을 만듭니다.
- 위치를 검색할 `mapSearch`를 생성합니다
- `mapSearch`의 결과를 다룰 `search`observable을 업데이트 합니다
- 지도 이벤트와 날씨결과를 제대로 다룰 `running observable`을 업데이트 합니다. 

먼저 `textSearch = ...` 바로 다음에 아래와 같은 코드를 추가합니다. 

```swift
// Drag 이벤트를 받아서, 화면의 가운데에 아이콘을 표시해주기위함!
let mapInput = mapView.rx.regionDidChangeAnimated
	.skip(1)
	.map { _ in self.mapView.centerCoordinate 
}
```

skip(1dms mapView가 초기화된 직후에 응용 프로그램이 검색을 시작하지 못하게 합니다.)

다음으로 `mapInput`을 사용하여 날씨 데이터를 가져오는 `mapSearch` observable 객체를 만듭니다.

```swift

let mapSearch = mapInput.flatMap { coordinate in
            return ApiController.shared.currentWeather(lat: coordinate.latitude,lon: coordinate.longitude)
                .catchErrorJustReturn(ApiController.Weather.dummy)
        }
```

두개의 `observable`을 만들었으니, 이제 결과를 나타내는 `search observable`과 상태를 나타내는 `running` 다음과 같이 `search`를 리펙토링합니다.

```swift
let search = Observable.from([geoSearch, textSearch, mapSearch])

let running = Observable.from([searchInput.map { _ in true },
                               geoInput.map { _ in true },
                               mapInput.map { _ in true},
                               search.map { _ in false }.asObservable()])
```

이전과 같이 간단하게 `mapInput.map { _ in true}` 를 체인된 Array에 추가하면됩니다. 


---

## Conclusion about RxCocoa 

2개의 RxCocoa chapter에서 RxSwift의 놀라운 extension 기능중 가장 흥미로운 부분을 엿볼수 있었습니다. 

RxCocoa는 필수는 아닙니다. Application에 지금까지 한 모든것들을 전혀 사용하지 않고도 Application을 작성할수 있습니다. 하지만 이미 당신은 RxCocoa를 당신의 Application에 어떻게 유용하게 사용할지에 대한 방법을 이미 알고 있는것으로 보입니다.

다음은 RxCocoa의 큰 장점을 요약한 목록입니다. 

- 이미 가장 자주 사용되는 구성 요소에 대해 많은 extension을 통합합니다.
- 기본 UI 구성 요소를 뛰어 넘습니다
- `Traits`를 사용해서 코드를 안전하게 해줍니다.
- `bind`와 `drive`를 통해서 쉽게 사용할수 있습니다.
- 사용자화한 확장을 만들수 있는 모든 메커니즘을 제공합니다.

---

## 추가로 Signal!

- RxSwift 4.0에서는 Signal이라는 새로운 trait을 소개했습니다. 문서에선 다음과 같은 특성을 소개하고 있습니다.
	- It can't fail 실패할 수 없습니다.
	- Events are sharing only when connected 이벤트는 연결되었을 때만 공유됩니다.
	- All events are delivered in the main scheduler 모든 이벤트는 메인 스케줄러로 보내집니다.
- 이렇게 보면 `Driver`의 대체라고 볼 수도 있습니다. 하지만 하나 중요한 내용이 있습니다. 바로 구독한 뒤 마지막 이벤트에 대해서는 `replay` 하지 않는다는 것압나다.
- `Driver`와 `Signal`의 차이점은 `BehaviorSubject`와 `PublishSubject`의 차이와 비슷합니다.
- 상황에 따라 어떤 것을 사용해야할지 판단해야할 때는 스스로 `"리소스에 연결했을 때, 마지막 이벤트에 대한 replay가 필요한가?"`를 생각해봅니다. 만약 필요없다면 `Signal`이 좋은 옵션이 될 수 있습니다. 필요하다면 `Driver`가 해결책입니다.

---

## Challenge 1: Add a binding property to focus the map on a given point

- 사용자가 text field나 위치 버튼을 눌렀을 때의 작동을 수정해봅니다. 현재 앱에서는 지도로 제대로 이동하지 않습니다.
- 다음과 같은 과정을 통해 개선해보자.
	- coordinate 객체를 갖는 바인딩 프로퍼티를 생성하고, 지도를 주어진 지점으로 이동하여 업데이트 합니다.
	- geoSearch와 textSearch에 대한 결과를 새로운 바인딩 프로퍼티로 바인딩합니다.
- 문제를 제대로 풀었다면, 도시명 또는 위치 정보가 입력될 때마다 지도가 해당 위치로 제대로 포커스 되어야 합니다.


---


## Challenge 2: Use the MKMapView to navigate a location and display the surrounding weather conditions

- 현재 앱에서는 단 하나의 위치에 대해서만 날씨가 표시되고 있다. 이 작동을 개선해보자.
- 다음과 같은 과정을 통해 수정할 수 있습니다.
	- coordinate를 갖고 주변 위치를 포함하는 array의 observable을 반환하는 새 `currentWeatherAround`를 생성합니다.
	- 적절한 연산자를 사용하여, 이 요청들을 병합합니다. 병합이 진행중일 때도 앱이 계속 응답하고 실행상태가 계속 업데이트 되는지 확인해야 합니다.
	- 결과 observable을 .rx.overlays로 바인드 합니다.
- 문제를 제대로 풀었다면, 지도상 여러개의 오버레이가 표시될 것이며, 지도상 표시된 여러 위치에 대한 날씨가 표시될 것입니다다.

--- 

## Reference 

* 공식 

[http://reactivex.io](http://reactivex.io/documentation/ko/observable.html) <br> 
[Introduce to Rx](http://www.introtorx.com/Content/v1.0.10621.0/00_Foreword.html) <br>
[RxJS Marbles](http://rxmarbles.com/) <br>
[RxSwift github](https://github.com/ReactiveX/RxSwift) <br>
[http://community.rxswift.org/](http://community.rxswift.org/) <br>


* 개인 참조 

[Raywenderlich Swift Guideline](https://github.com/raywenderlich/swift-style-guide#extending-object-lifetime) <br>
[https://github.com/devminjun/RxSwift_Practice](https://github.com/devminjun/RxSwift_Practice)<br>
[fimuxd님 github](https://github.com/fimuxd/RxSwift/blob/master/Lectures/13_Intermediate%20RxCocoa/Ch13.Intermediate%20RxCocoa.md)<br>

* Traits 

[reactive-single](http://reactivex.io/documentation/single.html) <br>
[https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md](https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md) <br>
[https://brunch.co.kr/@tilltue/33](https://brunch.co.kr/@tilltue/33) <br>

---






